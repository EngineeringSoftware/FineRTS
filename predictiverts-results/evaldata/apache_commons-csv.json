[
    {
        "commit": "b322e2f2",
        "prev_commit": "5c138549",
        "changed_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java"
        ],
        "changed_files_num": 1,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java"
        ],
        "changed_java_files_num": 1,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "FercGovTest",
            "CSVParserTest",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 5,
            "CSVFormatTest": 45,
            "CSVParserTest": 67,
            "CSVPrinterTest": 61,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "FercGovTest": 2,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+    public CSVFormat withTrim(final boolean trim) {\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+    }\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                1501,
                1502,
                1503,
                1504,
                1505
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                1466,
                1467,
                1468,
                1469,
                1470
            ]
        }
    },
    {
        "commit": "4a6af459",
        "prev_commit": "21cb8b47",
        "changed_files": [
            "pom.xml",
            "src/changes/changes.xml",
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/main/java/org/apache/commons/csv/CSVPrinter.java"
        ],
        "changed_files_num": 4,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/main/java/org/apache/commons/csv/CSVPrinter.java"
        ],
        "changed_java_files_num": 2,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "FercGovTest",
            "CSVParserTest",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 5,
            "CSVFormatTest": 45,
            "CSVParserTest": 67,
            "CSVPrinterTest": 61,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "FercGovTest": 2,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+  <version>1.4-SNAPSHOT</version>\n+    <release version=\"1.4\" date=\"2016-MM-DD\" description=\"Feature and bug fix release\">\n+      <action issue=\"CSV-182\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Allow some printing operations directly from CSVFormat.</action>\n+    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n+        CharSequence charSequence;\n+        if (value == null) {\n+            charSequence = nullString == null ? Constants.EMPTY : nullString;\n+        } else {\n+            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n+        }\n+        charSequence = getTrim() ? trim(charSequence) : charSequence;\n+        this.print(value, charSequence, 0, charSequence.length(), out, newRecord);\n+    }\n+    private void print(final Object object, final CharSequence value, final int offset, final int len,\n+            final Appendable out, final boolean newRecord) throws IOException {\n+        if (!newRecord) {\n+            out.append(getDelimiter());\n+        }\n+        if (object == null) {\n+            out.append(value);\n+        } else if (isQuoteCharacterSet()) {\n+            printAndQuote(object, value, offset, len, out, newRecord);\n+        } else if (isEscapeCharacterSet()) {\n+            printAndEscape(value, offset, len, out);\n+        } else {\n+            out.append(value, offset, offset + len);\n+        }\n+    }\n+    private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out)\n+            throws IOException {\n+        int start = offset;\n+        int pos = offset;\n+        final int end = offset + len;\n+        final char delim = getDelimiter();\n+        final char escape = getEscapeCharacter().charValue();\n+        while (pos < end) {\n+            char c = value.charAt(pos);\n+            if (c == CR || c == LF || c == delim || c == escape) {\n+                if (pos > start) {\n+                    out.append(value, start, pos);\n+                }\n+                if (c == LF) {\n+                    c = 'n';\n+                } else if (c == CR) {\n+                    c = 'r';\n+                }\n+                out.append(escape);\n+                out.append(c);\n+                start = pos + 1; // start on the current char after this one\n+            }\n+            pos++;\n+        }\n+        if (pos > start) {\n+            out.append(value, start, pos);\n+        }\n+    }\n+    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n+            final Appendable out, final boolean newRecord) throws IOException {\n+        boolean quote = false;\n+        int start = offset;\n+        int pos = offset;\n+        final int end = offset + len;\n+        final char delimChar = getDelimiter();\n+        final char quoteChar = getQuoteCharacter().charValue();\n+        QuoteMode quoteModePolicy = getQuoteMode();\n+        if (quoteModePolicy == null) {\n+            quoteModePolicy = QuoteMode.MINIMAL;\n+        }\n+        switch (quoteModePolicy) {\n+        case ALL:\n+            quote = true;\n+            break;\n+        case NON_NUMERIC:\n+            quote = !(object instanceof Number);\n+            break;\n+        case NONE:\n+            printAndEscape(value, offset, len, out);\n+            return;\n+        case MINIMAL:\n+            if (len <= 0) {\n+                if (newRecord) {\n+                    quote = true;\n+                }\n+            } else {\n+                char c = value.charAt(pos);\n+                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+                    quote = true;\n+                } else if (c <= COMMENT) {\n+                    quote = true;\n+                } else {\n+                    while (pos < end) {\n+                        c = value.charAt(pos);\n+                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n+                            quote = true;\n+                            break;\n+                        }\n+                        pos++;\n+                    }\n+                    if (!quote) {\n+                        pos = end - 1;\n+                        c = value.charAt(pos);\n+                        if (c <= SP) {\n+                            quote = true;\n+                        }\n+                    }\n+                }\n+            }\n+            if (!quote) {\n+                out.append(value, start, end);\n+                return;\n+            }\n+            break;\n+        default:\n+            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n+        }\n+        if (!quote) {\n+            out.append(value, start, end);\n+            return;\n+        }\n+        out.append(quoteChar);\n+        while (pos < end) {\n+            final char c = value.charAt(pos);\n+            if (c == quoteChar) {\n+                out.append(value, start, pos + 1);\n+                start = pos;\n+            }\n+            pos++;\n+        }\n+        out.append(value, start, pos);\n+        out.append(quoteChar);\n+    }\n+    public void println(final Appendable out) throws IOException {\n+        if (getTrailingDelimiter()) {\n+            out.append(getDelimiter());\n+        }\n+        if (recordSeparator != null) {\n+            out.append(recordSeparator);\n+        }\n+    }\n+    public void printRecord(final Appendable out, final Object... values) throws IOException {\n+        for (int i = 0; i < values.length; i++) {\n+            print(values[i], out, i == 0);\n+        }\n+        println(out);\n+    }\n+    private CharSequence trim(final CharSequence charSequence) {\n+        if (charSequence instanceof String) {\n+            return ((String) charSequence).trim();\n+        }\n+        final int count = charSequence.length();\n+        int len = count;\n+        int pos = 0;\n+        while ((pos < len) && (charSequence.charAt(pos) <= ' ')) {\n+            pos++;\n+        }\n+        while ((pos < len) && (charSequence.charAt(len - 1) <= ' ')) {\n+            len--;\n+        }\n+        return (pos > 0) || (len < count) ? charSequence.subSequence(pos, len) : charSequence;\n+    }\n+        format.print(value, out, newRecord);\n+        format.println(out);\n+        format.printRecord(out, values);\n+        newRecord = true;\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "import static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.SP;\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        CharSequence charSequence;\n        if (value == null) {\n            charSequence = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        this.print(value, charSequence, 0, charSequence.length(), out, newRecord);\n    }\n    private void print(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            printAndQuote(object, value, offset, len, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len, out);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n    }\n    private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out)\n            throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n                out.append(escape);\n                out.append(c);\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n        out.append(quoteChar);\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(value, start, pos + 1);\n                start = pos;\n            }\n            pos++;\n        }\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n        while ((pos < len) && (charSequence.charAt(pos) <= ' ')) {\n            pos++;\n        }\n        while ((pos < len) && (charSequence.charAt(len - 1) <= ' ')) {\n            len--;\n        }\n        return (pos > 0) || (len < count) ? charSequence.subSequence(pos, len) : charSequence;\n    }\n",
            "src/main/java/org/apache/commons/csv/CSVPrinter.java": "        format.print(value, out, newRecord);\n        format.println(out);\n        format.printRecord(out, values);\n        newRecord = true;\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                22,
                28,
                880,
                883,
                884,
                885,
                886,
                887,
                888,
                889,
                890,
                891,
                893,
                894,
                895,
                896,
                897,
                898,
                899,
                900,
                902,
                903,
                904,
                905,
                906,
                907,
                908,
                913,
                914,
                915,
                916,
                917,
                919,
                920,
                922,
                923,
                924,
                926,
                927,
                928,
                929,
                930,
                931,
                932,
                933,
                935,
                936,
                938,
                939,
                941,
                942,
                945,
                946,
                947,
                948,
                954,
                955,
                956,
                957,
                958,
                959,
                961,
                962,
                964,
                965,
                966,
                967,
                968,
                969,
                970,
                971,
                972,
                973,
                974,
                975,
                977,
                978,
                979,
                980,
                985,
                986,
                987,
                988,
                989,
                992,
                993,
                994,
                998,
                999,
                1000,
                1001,
                1002,
                1003,
                1004,
                1005,
                1006,
                1007,
                1009,
                1010,
                1011,
                1014,
                1015,
                1016,
                1017,
                1018,
                1019,
                1021,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1031,
                1033,
                1034,
                1035,
                1038,
                1042,
                1043,
                1044,
                1048,
                1051,
                1052,
                1053,
                1054,
                1057,
                1058,
                1059,
                1071,
                1072,
                1073,
                1074,
                1075,
                1076,
                1077,
                1078,
                1095,
                1096,
                1097,
                1098,
                1099,
                1100,
                1159,
                1160,
                1161,
                1162,
                1163,
                1164,
                1165,
                1167,
                1168,
                1169,
                1170,
                1171,
                1172,
                1173,
                1174
            ],
            "src/main/java/org/apache/commons/csv/CSVPrinter.java": [
                122,
                178,
                216,
                217
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVPrinter.java": "import static org.apache.commons.csv.Constants.COMMENT;\n        CharSequence charSequence;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            charSequence = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n        }\n        charSequence = format.getTrim() ? trim(charSequence) : charSequence;\n        this.print(value, charSequence, 0, charSequence.length());\n    }\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n        while ((pos < len) && (charSequence.charAt(pos) <= ' ')) {\n            pos++;\n        }\n        while ((pos < len) && (charSequence.charAt(len - 1) <= ' ')) {\n            len--;\n        }\n        return (pos > 0) || (len < count) ? charSequence.subSequence(pos, len) : charSequence;\n    }\n    private void print(final Object object, final CharSequence value, final int offset, final int len)\n            throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (format.isQuoteCharacterSet()) {\n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscapeCharacter().charValue();\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n                out.append(escape);\n                out.append(c);\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len)\n            throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteCharacter().charValue();\n        QuoteMode quoteModePolicy = format.getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n        out.append(quoteChar);\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(value, start, pos + 1);\n                start = pos;\n            }\n            pos++;\n        }\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n        if (format.getTrailingDelimiter()) {\n            out.append(format.getDelimiter());\n        }\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVPrinter.java": [
                20,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                162,
                163,
                164,
                165,
                166,
                167,
                174,
                175,
                176,
                177,
                179,
                180,
                182,
                183,
                184,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                195,
                196,
                198,
                199,
                201,
                202,
                205,
                206,
                207,
                208,
                214,
                215,
                216,
                217,
                218,
                219,
                221,
                222,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                237,
                238,
                239,
                240,
                245,
                246,
                247,
                248,
                249,
                252,
                253,
                254,
                258,
                259,
                260,
                261,
                262,
                263,
                264,
                265,
                266,
                267,
                269,
                270,
                271,
                274,
                275,
                276,
                277,
                278,
                279,
                281,
                283,
                284,
                285,
                286,
                287,
                288,
                289,
                291,
                293,
                294,
                295,
                298,
                302,
                303,
                304,
                308,
                311,
                312,
                313,
                314,
                317,
                318,
                319,
                373,
                374,
                375,
                376,
                377,
                378,
                379,
                417,
                418,
                419,
                420
            ]
        }
    },
    {
        "commit": "b502c5a2",
        "prev_commit": "8b24cd1f",
        "changed_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java"
        ],
        "changed_files_num": 1,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java"
        ],
        "changed_java_files_num": 1,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "FercGovTest",
            "CSVParserTest",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 5,
            "CSVFormatTest": 45,
            "CSVParserTest": 67,
            "CSVPrinterTest": 61,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "FercGovTest": 2,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n+        String[] header = null;\n+        if (headerEnum != null) {\n+            Enum<?>[] enumValues = headerEnum.getEnumConstants();\n+            header = new String[enumValues.length];\n+            for (int i = 0; i < enumValues.length; i++) {\n+                header[i] = enumValues[i].name();\n+            }\n+        }\n+        return withHeader(header);\n+    }\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                1122,
                1123,
                1124,
                1125,
                1126,
                1127,
                1128,
                1129,
                1130,
                1131,
                1132
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                1219,
                1220,
                1221,
                1222,
                1223,
                1224,
                1225,
                1226,
                1227,
                1228,
                1229
            ]
        }
    },
    {
        "commit": "4def868a",
        "prev_commit": "04b36452",
        "changed_files": [
            "src/changes/changes.xml",
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/test/java/org/apache/commons/csv/CSVFormatTest.java"
        ],
        "changed_files_num": 3,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/test/java/org/apache/commons/csv/CSVFormatTest.java"
        ],
        "changed_java_files_num": 2,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "FercGovTest",
            "CSVParserTest",
            "CSVFormatTest",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 5,
            "CSVFormatTest": 46,
            "CSVParserTest": 67,
            "CSVPrinterTest": 61,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "FercGovTest": 2,
            "JiraCsv167Test": 1,
            "LexerTest": 26,
            "TokenMatchersTest": 4
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+      <action issue=\"CSV-180\" type=\"add\" dev=\"britter\">Add withHeader(Class&lt;? extends Enum&gt;) to CSVFormat</action>\n+    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n+        String[] header = null;\n+        if (headerEnum != null) {\n+            Enum<?>[] enumValues = headerEnum.getEnumConstants();\n+            header = new String[enumValues.length];\n+            for (int i = 0; i < enumValues.length; i++) {\n+                header[i] = enumValues[i].name();\n+            }\n+        }\n+        return withHeader(header);\n+    }\n+    @Test\n+    public void testWithHeaderEnum() throws Exception {\n+        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(Header.class);\n+        assertArrayEquals(new String[]{ \"Name\", \"Email\", \"Phone\" }, formatWithHeader.getHeader());\n+    }\n+    @Test\n+    public void testWithEmptyEnum() throws Exception {\n+        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(EmptyEnum.class);\n+        Assert.assertTrue(formatWithHeader.getHeader().length == 0);\n+    }\n+    public enum Header {\n+        Name, Email, Phone\n+    }\n+    public enum EmptyEnum {\n+    }\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n",
            "src/test/java/org/apache/commons/csv/CSVFormatTest.java": "import static org.junit.Assert.*;\n    @Test\n    public void testWithHeaderEnum() throws Exception {\n        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(Header.class);\n        assertArrayEquals(new String[]{ \"Name\", \"Email\", \"Phone\" }, formatWithHeader.getHeader());\n    }\n    @Test\n    public void testWithEmptyEnum() throws Exception {\n        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(EmptyEnum.class);\n        Assert.assertTrue(formatWithHeader.getHeader().length == 0);\n    }\n    public enum Header {\n        Name, Email, Phone\n    }\n    public enum EmptyEnum {\n    }\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                1197,
                1198,
                1199,
                1200,
                1201,
                1202,
                1203,
                1204,
                1205,
                1206,
                1207
            ],
            "src/test/java/org/apache/commons/csv/CSVFormatTest.java": [
                24,
                374,
                375,
                376,
                377,
                378,
                380,
                381,
                382,
                383,
                384,
                465,
                466,
                467,
                469,
                470
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/test/java/org/apache/commons/csv/CSVFormatTest.java": "import static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNotSame;\nimport static org.junit.Assert.assertTrue;\n"
        },
        "deleted_line_number_list_per_file": {
            "src/test/java/org/apache/commons/csv/CSVFormatTest.java": [
                24,
                25,
                26,
                27,
                28,
                29
            ]
        }
    },
    {
        "commit": "9ae4b56c",
        "prev_commit": "09cf3739",
        "changed_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java"
        ],
        "changed_files_num": 1,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java"
        ],
        "changed_java_files_num": 1,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "CSVParserTest",
            "JiraCsv203Test",
            "JiraCsv198Test",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 5,
            "CSVFormatTest": 47,
            "CSVParserTest": 69,
            "CSVPrinterTest": 75,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1,
            "JiraCsv198Test": 1,
            "JiraCsv203Test": 7
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+            .withNullString(\"\\\\N\")\n+    \t\t.withQuoteMode(QuoteMode.ALL_NON_NULL);\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "            .withNullString(\"\\\\N\")\n    \t\t.withQuoteMode(QuoteMode.ALL_NON_NULL);\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                365,
                366
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "            .withNullString(\"\\\\N\");\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                365
            ]
        }
    },
    {
        "commit": "3a203443",
        "prev_commit": "34262e8c",
        "changed_files": [
            "src/changes/changes.xml",
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/test/java/org/apache/commons/csv/CSVFormatTest.java"
        ],
        "changed_files_num": 3,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/test/java/org/apache/commons/csv/CSVFormatTest.java"
        ],
        "changed_java_files_num": 2,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "CSVParserTest",
            "JiraCsv203Test",
            "JiraCsv213Test",
            "JiraCsv198Test",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 7,
            "CSVFormatTest": 56,
            "CSVParserTest": 72,
            "CSVPrinterTest": 90,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1,
            "JiraCsv198Test": 1,
            "JiraCsv203Test": 7,
            "JiraCsv213Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+      <action issue=\"CSV-220\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add API org.apache.commons.csv.CSVFormat.withSystemRecordSeparator().</action>\n+    public CSVFormat withSystemRecordSeparator() {\n+        return withRecordSeparator(System.getProperty(\"line.separator\"));\n+    }\n+        final String string = CSVFormat.INFORMIX_UNLOAD.toString();\n+    @Test\n+    public void testWithSystemRecordSeparator() throws Exception {\n+        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withSystemRecordSeparator();\n+        assertEquals(System.getProperty(\"line.separator\"), formatWithRecordSeparator.getRecordSeparator());\n+    }\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "    public CSVFormat withSystemRecordSeparator() {\n        return withRecordSeparator(System.getProperty(\"line.separator\"));\n    }\n",
            "src/test/java/org/apache/commons/csv/CSVFormatTest.java": "        final String string = CSVFormat.INFORMIX_UNLOAD.toString();\n    @Test\n    public void testWithSystemRecordSeparator() throws Exception {\n        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withSystemRecordSeparator();\n        assertEquals(System.getProperty(\"line.separator\"), formatWithRecordSeparator.getRecordSeparator());\n    }\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                1940,
                1941,
                1942
            ],
            "src/test/java/org/apache/commons/csv/CSVFormatTest.java": [
                643,
                1093,
                1094,
                1095,
                1096,
                1097
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/test/java/org/apache/commons/csv/CSVFormatTest.java": "        final String string = cSVFormat.INFORMIX_UNLOAD.toString();\n"
        },
        "deleted_line_number_list_per_file": {
            "src/test/java/org/apache/commons/csv/CSVFormatTest.java": [
                643
            ]
        }
    },
    {
        "commit": "8b3de71f",
        "prev_commit": "e76c4d80",
        "changed_files": [
            "src/changes/changes.xml",
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java"
        ],
        "changed_files_num": 3,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java"
        ],
        "changed_java_files_num": 2,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "CSVParserTest",
            "JiraCsv203Test",
            "JiraCsv213Test",
            "JiraCsv198Test",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 7,
            "CSVFormatTest": 55,
            "CSVParserTest": 72,
            "CSVPrinterTest": 90,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1,
            "JiraCsv198Test": 1,
            "JiraCsv203Test": 7,
            "JiraCsv213Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+      <action issue=\"CSV-219\" type=\"fix\" dev=\"ggregory\" due-to=\"Zhang Hongda\">The behavior of quote char using is not similar as Excel does when the first string contains CJK char(s).</action>\n+      <action issue=\"CSV-172\" type=\"fix\" dev=\"ggregory\" due-to=\"Andrew Pennebaker\">Don't quote cells just because they have UTF-8 encoded characters.</action>\n+                if (c <= COMMENT) {\n+    public void testDontQuoteEuroFirstChar() throws IOException {\n+            assertEquals(EURO_CH + \",Deux\" + recordSeparator, sw.toString());\n+        }\n+    }\n+    @Test\n+    public void testQuoteCommaFirstChar() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\n+            printer.printRecord(\",\");\n+            assertEquals(\"\\\",\\\"\" + recordSeparator, sw.toString());\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "                if (c <= COMMENT) {\n",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": "    public void testDontQuoteEuroFirstChar() throws IOException {\n            assertEquals(EURO_CH + \",Deux\" + recordSeparator, sw.toString());\n        }\n    }\n    @Test\n    public void testQuoteCommaFirstChar() throws IOException {\n        final StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\n            printer.printRecord(\",\");\n            assertEquals(\"\\\",\\\"\" + recordSeparator, sw.toString());\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                1189
            ],
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": [
                1036,
                1040,
                1041,
                1042,
                1044,
                1045,
                1046,
                1047,
                1048,
                1049
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": "    public void testRfc4180QuoteSingleChar() throws IOException {\n            assertEquals(\"\\\"\" + EURO_CH + \"\\\",Deux\" + recordSeparator, sw.toString());\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                1190,
                1191,
                1192
            ],
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": [
                1036,
                1040
            ]
        }
    },
    {
        "commit": "aae6f904",
        "prev_commit": "4d0f2260",
        "changed_files": [
            "src/changes/changes.xml",
            "src/main/java/org/apache/commons/csv/CSVParser.java",
            "src/main/java/org/apache/commons/csv/Lexer.java",
            "src/test/java/org/apache/commons/csv/CSVParserTest.java"
        ],
        "changed_files_num": 4,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVParser.java",
            "src/main/java/org/apache/commons/csv/Lexer.java",
            "src/test/java/org/apache/commons/csv/CSVParserTest.java"
        ],
        "changed_java_files_num": 3,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "CSVParserTest",
            "JiraCsv203Test",
            "JiraCsv213Test",
            "JiraCsv198Test",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 7,
            "CSVFormatTest": 55,
            "CSVParserTest": 72,
            "CSVPrinterTest": 84,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1,
            "JiraCsv198Test": 1,
            "JiraCsv203Test": 7,
            "JiraCsv213Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+      <action issue=\"CSV-214\" type=\"add\" dev=\"ggregory\" due-to=\"Nitin Mahendru, Gary Gregory\">Adding a placeholder in the Lexer and CSV parser to store the end-of-line string.</action>\n+    public String getFirstEndOfLine() {\n+        return lexer.getFirstEol();\n+    }\n+    private static final String CR_STRING = Character.toString(Constants.CR);\n+    private static final String LF_STRING = Character.toString(Constants.LF);\n+    private String firstEol;\n+    String getFirstEol(){\n+        return firstEol;\n+    }\n+    \n+            if (firstEol == null) {\n+                this.firstEol = Constants.CRLF;\n+            }\n+        if (firstEol == null) {\n+            if (ch == LF) {\n+                this.firstEol = LF_STRING;\n+            } else if (ch == CR) {\n+                this.firstEol = CR_STRING;\n+            }\n+        }\n+    \n+    @Test\n+    public void testFirstEndOfLineCrLf() throws IOException {\n+        final String data = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n+        try (final CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+            assertEquals(\"\\r\\n\", parser.getFirstEndOfLine());\n+        }\n+    }\n+    \n+    @Test\n+    public void testFirstEndOfLineLf() throws IOException {\n+        final String data = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n+        try (final CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+            assertEquals(\"\\n\", parser.getFirstEndOfLine());\n+        }\n+    }\n+    @Test\n+    public void testFirstEndOfLineCr() throws IOException {\n+        final String data = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n+        try (final CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+            assertEquals(\"\\r\", parser.getFirstEndOfLine());\n+        }\n+    }\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": "    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n",
            "src/main/java/org/apache/commons/csv/Lexer.java": "    private static final String CR_STRING = Character.toString(Constants.CR);\n    private static final String LF_STRING = Character.toString(Constants.LF);\n    private String firstEol;\n    String getFirstEol(){\n        return firstEol;\n    }\n            if (firstEol == null) {\n                this.firstEol = Constants.CRLF;\n            }\n        if (firstEol == null) {\n            if (ch == LF) {\n                this.firstEol = LF_STRING;\n            } else if (ch == CR) {\n                this.firstEol = CR_STRING;\n            }\n        }\n",
            "src/test/java/org/apache/commons/csv/CSVParserTest.java": "    @Test\n    public void testFirstEndOfLineCrLf() throws IOException {\n        final String data = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n        try (final CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n            final List<CSVRecord> records = parser.getRecords();\n            assertEquals(4, records.size());\n            assertEquals(\"\\r\\n\", parser.getFirstEndOfLine());\n        }\n    }\n    @Test\n    public void testFirstEndOfLineLf() throws IOException {\n        final String data = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n        try (final CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n            final List<CSVRecord> records = parser.getRecords();\n            assertEquals(4, records.size());\n            assertEquals(\"\\n\", parser.getFirstEndOfLine());\n        }\n    }\n    @Test\n    public void testFirstEndOfLineCr() throws IOException {\n        final String data = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n        try (final CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n            final List<CSVRecord> records = parser.getRecords();\n            assertEquals(4, records.size());\n            assertEquals(\"\\r\", parser.getFirstEndOfLine());\n        }\n    }\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": [
                405,
                406,
                407
            ],
            "src/main/java/org/apache/commons/csv/Lexer.java": [
                43,
                44,
                63,
                65,
                66,
                67,
                386,
                387,
                388,
                391,
                392,
                393,
                394,
                395,
                396,
                397
            ],
            "src/test/java/org/apache/commons/csv/CSVParserTest.java": [
                238,
                239,
                240,
                241,
                242,
                243,
                244,
                245,
                246,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255,
                256,
                258,
                259,
                260,
                261,
                262,
                263,
                264,
                265,
                266
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {},
        "deleted_line_number_list_per_file": {}
    },
    {
        "commit": "34262e8c",
        "prev_commit": "4f58df6d",
        "changed_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java"
        ],
        "changed_files_num": 1,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java"
        ],
        "changed_java_files_num": 1,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "CSVParserTest",
            "JiraCsv203Test",
            "JiraCsv213Test",
            "JiraCsv198Test",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 7,
            "CSVFormatTest": 55,
            "CSVParserTest": 72,
            "CSVPrinterTest": 90,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1,
            "JiraCsv198Test": 1,
            "JiraCsv203Test": 7,
            "JiraCsv213Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+    public boolean getAutoFlush() {\n+        return autoFlush;\n+    }\n+    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n+        return print(Files.newBufferedWriter(out, charset));\n+    }\n+    public CSVPrinter printer() throws IOException {\n+        return new CSVPrinter(System.out, this);\n+    }\n+    public CSVFormat withAutoFlush(final boolean autoFlush) {\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+            ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n+            skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+    }\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n            ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n            skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                757,
                758,
                759,
                1087,
                1088,
                1089,
                1252,
                1253,
                1254,
                1457,
                1458,
                1459,
                1460,
                1461
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n            ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n            skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                900,
                901,
                902,
                1008,
                1009,
                1010,
                1050,
                1051,
                1052,
                1972,
                1973,
                1974,
                1975,
                1976
            ]
        }
    },
    {
        "commit": "259812ec",
        "prev_commit": "431f8236",
        "changed_files": [
            "src/main/java/org/apache/commons/csv/CSVParser.java"
        ],
        "changed_files_num": 1,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVParser.java"
        ],
        "changed_java_files_num": 1,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "CSVParserTest",
            "JiraCsv203Test",
            "JiraCsv213Test",
            "JiraCsv198Test",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 7,
            "CSVFormatTest": 55,
            "CSVParserTest": 72,
            "CSVPrinterTest": 84,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1,
            "JiraCsv198Test": 1,
            "JiraCsv203Test": 7,
            "JiraCsv213Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+    private final List<String> recordList = new ArrayList<>();\n+        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n+        this.recordList.clear();\n+        if (!this.recordList.isEmpty()) {\n+            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": "    private final List<String> recordList = new ArrayList<>();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n        this.recordList.clear();\n        if (!this.recordList.isEmpty()) {\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": [
                289,
                367,
                580,
                614,
                617
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": "    private final List<String> record = new ArrayList<>();\n        this.record.add(inputClean.equals(nullString) ? null : inputClean);\n        this.record.clear();\n        if (!this.record.isEmpty()) {\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": [
                289,
                367,
                580,
                614,
                617
            ]
        }
    },
    {
        "commit": "676a580c",
        "prev_commit": "47dbc8fd",
        "changed_files": [
            "src/main/java/org/apache/commons/csv/CSVPrinter.java"
        ],
        "changed_files_num": 1,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVPrinter.java"
        ],
        "changed_java_files_num": 1,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "CSVParserTest",
            "JiraCsv203Test",
            "JiraCsv213Test",
            "JiraCsv198Test",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 8,
            "CSVFormatTest": 56,
            "CSVParserTest": 75,
            "CSVPrinterTest": 91,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1,
            "JiraCsv198Test": 1,
            "JiraCsv203Test": 7,
            "JiraCsv213Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+            flush();\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVPrinter.java": "            flush();\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVPrinter.java": [
                97
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVPrinter.java": "            if (out instanceof Flushable) {\n                ((Flushable) out).flush();\n            }\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVPrinter.java": [
                97,
                98,
                99
            ]
        }
    },
    {
        "commit": "97782449",
        "prev_commit": "a7757849",
        "changed_files": [
            "src/changes/changes.xml",
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/main/java/org/apache/commons/csv/QuoteMode.java",
            "src/test/java/org/apache/commons/csv/issues/JiraCsv203Test.java"
        ],
        "changed_files_num": 4,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/main/java/org/apache/commons/csv/QuoteMode.java",
            "src/test/java/org/apache/commons/csv/issues/JiraCsv203Test.java"
        ],
        "changed_java_files_num": 3,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "CSVParserTest",
            "JiraCsv203Test",
            "JiraCsv198Test",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 5,
            "CSVFormatTest": 47,
            "CSVParserTest": 69,
            "CSVPrinterTest": 75,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1,
            "JiraCsv198Test": 1,
            "JiraCsv203Test": 7
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+    <release version=\"1.5\" date=\"2017-MM-DD\" description=\"Bug fix release\">\n+      <action issue=\"CSV-203\" type=\"fix\" dev=\"ggregory\" due-to=\"Richard Wheeldon, Kai Paroth\">withNullString value is printed without quotes when QuoteMode.ALL is specified; add QuoteMode.ALL_NON_NULL. PR #17.</action>\n+            if (null == nullString) {\n+                charSequence = Constants.EMPTY;\n+            } else {\n+                if (QuoteMode.ALL == quoteMode) {\n+                    charSequence = quoteCharacter + nullString + quoteCharacter;\n+                } else {\n+                    charSequence = nullString;\n+                }\n+            }\n+        case ALL_NON_NULL:\n+    ALL_NON_NULL,\n+    @Test\n+    public void testQuoteModeAll() throws Exception {\n+        CSVFormat format = CSVFormat.EXCEL\n+                .withNullString(\"N/A\")\n+                .withIgnoreSurroundingSpaces(true)\n+                .withQuoteMode(QuoteMode.ALL);\n+        StringBuffer buffer = new StringBuffer();\n+        CSVPrinter printer = new CSVPrinter(buffer, format);\n+        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n+        Assert.assertEquals(\"\\\"N/A\\\",\\\"Hello\\\",\\\"N/A\\\",\\\"World\\\"\\r\\n\", buffer.toString());\n+    }\n+    @Test\n+    public void testQuoteModeAllNonNull() throws Exception {\n+        CSVFormat format = CSVFormat.EXCEL\n+                .withNullString(\"N/A\")\n+                .withIgnoreSurroundingSpaces(true)\n+                .withQuoteMode(QuoteMode.ALL_NON_NULL);\n+        StringBuffer buffer = new StringBuffer();\n+        CSVPrinter printer = new CSVPrinter(buffer, format);\n+        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n+        Assert.assertEquals(\"N/A,\\\"Hello\\\",N/A,\\\"World\\\"\\r\\n\", buffer.toString());\n+    }\n+    @Test\n+    public void testWithoutQuoteMode() throws Exception {\n+        CSVFormat format = CSVFormat.EXCEL\n+                .withNullString(\"N/A\")\n+                .withIgnoreSurroundingSpaces(true);\n+        StringBuffer buffer = new StringBuffer();\n+        CSVPrinter printer = new CSVPrinter(buffer, format);\n+        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n+        Assert.assertEquals(\"N/A,Hello,N/A,World\\r\\n\", buffer.toString());\n+    }\n+    @Test\n+    public void testQuoteModeMinimal() throws Exception {\n+        CSVFormat format = CSVFormat.EXCEL\n+                .withNullString(\"N/A\")\n+                .withIgnoreSurroundingSpaces(true)\n+                .withQuoteMode(QuoteMode.MINIMAL);\n+        StringBuffer buffer = new StringBuffer();\n+        CSVPrinter printer = new CSVPrinter(buffer, format);\n+        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n+        Assert.assertEquals(\"N/A,Hello,N/A,World\\r\\n\", buffer.toString());\n+    }\n+    @Test\n+    public void testQuoteModeNonNumeric() throws Exception {\n+        CSVFormat format = CSVFormat.EXCEL\n+                .withNullString(\"N/A\")\n+                .withIgnoreSurroundingSpaces(true)\n+                .withQuoteMode(QuoteMode.NON_NUMERIC);\n+        StringBuffer buffer = new StringBuffer();\n+        CSVPrinter printer = new CSVPrinter(buffer, format);\n+        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n+        Assert.assertEquals(\"N/A,\\\"Hello\\\",N/A,\\\"World\\\"\\r\\n\", buffer.toString());\n+    }\n+    @Test\n+    public void testWithoutNullString() throws Exception {\n+        CSVFormat format = CSVFormat.EXCEL\n+                .withIgnoreSurroundingSpaces(true)\n+                .withQuoteMode(QuoteMode.ALL);\n+        StringBuffer buffer = new StringBuffer();\n+        CSVPrinter printer = new CSVPrinter(buffer, format);\n+        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n+        Assert.assertEquals(\",\\\"Hello\\\",,\\\"World\\\"\\r\\n\", buffer.toString());\n+    }\n+    @Test\n+    public void testWithEmptyValues() throws Exception {\n+        CSVFormat format = CSVFormat.EXCEL\n+                .withNullString(\"N/A\")\n+                .withIgnoreSurroundingSpaces(true)\n+                .withQuoteMode(QuoteMode.ALL);\n+        StringBuffer buffer = new StringBuffer();\n+        CSVPrinter printer = new CSVPrinter(buffer, format);\n+        printer.printRecord(new Object[] { \"\", \"Hello\", \"\", \"World\" });\n+        Assert.assertEquals(\"\\\"\\\",\\\"Hello\\\",\\\"\\\",\\\"World\\\"\\r\\n\", buffer.toString());\n+    }\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "            if (null == nullString) {\n                charSequence = Constants.EMPTY;\n            } else {\n                if (QuoteMode.ALL == quoteMode) {\n                    charSequence = quoteCharacter + nullString + quoteCharacter;\n                } else {\n                    charSequence = nullString;\n                }\n            }\n        case ALL_NON_NULL:\n",
            "src/main/java/org/apache/commons/csv/QuoteMode.java": "    ALL_NON_NULL,\n",
            "src/test/java/org/apache/commons/csv/issues/JiraCsv203Test.java": "package org.apache.commons.csv.issues;\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVPrinter;\nimport org.apache.commons.csv.QuoteMode;\nimport org.junit.Assert;\nimport org.junit.Test;\npublic class JiraCsv203Test {\n    @Test\n    public void testQuoteModeAll() throws Exception {\n        CSVFormat format = CSVFormat.EXCEL\n                .withNullString(\"N/A\")\n                .withIgnoreSurroundingSpaces(true)\n                .withQuoteMode(QuoteMode.ALL);\n        StringBuffer buffer = new StringBuffer();\n        CSVPrinter printer = new CSVPrinter(buffer, format);\n        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n        Assert.assertEquals(\"\\\"N/A\\\",\\\"Hello\\\",\\\"N/A\\\",\\\"World\\\"\\r\\n\", buffer.toString());\n    }\n    @Test\n    public void testQuoteModeAllNonNull() throws Exception {\n        CSVFormat format = CSVFormat.EXCEL\n                .withNullString(\"N/A\")\n                .withIgnoreSurroundingSpaces(true)\n                .withQuoteMode(QuoteMode.ALL_NON_NULL);\n        StringBuffer buffer = new StringBuffer();\n        CSVPrinter printer = new CSVPrinter(buffer, format);\n        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n        Assert.assertEquals(\"N/A,\\\"Hello\\\",N/A,\\\"World\\\"\\r\\n\", buffer.toString());\n    }\n    @Test\n    public void testWithoutQuoteMode() throws Exception {\n        CSVFormat format = CSVFormat.EXCEL\n                .withNullString(\"N/A\")\n                .withIgnoreSurroundingSpaces(true);\n        StringBuffer buffer = new StringBuffer();\n        CSVPrinter printer = new CSVPrinter(buffer, format);\n        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n        Assert.assertEquals(\"N/A,Hello,N/A,World\\r\\n\", buffer.toString());\n    }\n    @Test\n    public void testQuoteModeMinimal() throws Exception {\n        CSVFormat format = CSVFormat.EXCEL\n                .withNullString(\"N/A\")\n                .withIgnoreSurroundingSpaces(true)\n                .withQuoteMode(QuoteMode.MINIMAL);\n        StringBuffer buffer = new StringBuffer();\n        CSVPrinter printer = new CSVPrinter(buffer, format);\n        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n        Assert.assertEquals(\"N/A,Hello,N/A,World\\r\\n\", buffer.toString());\n    }\n    @Test\n    public void testQuoteModeNonNumeric() throws Exception {\n        CSVFormat format = CSVFormat.EXCEL\n                .withNullString(\"N/A\")\n                .withIgnoreSurroundingSpaces(true)\n                .withQuoteMode(QuoteMode.NON_NUMERIC);\n        StringBuffer buffer = new StringBuffer();\n        CSVPrinter printer = new CSVPrinter(buffer, format);\n        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n        Assert.assertEquals(\"N/A,\\\"Hello\\\",N/A,\\\"World\\\"\\r\\n\", buffer.toString());\n    }\n    @Test\n    public void testWithoutNullString() throws Exception {\n        CSVFormat format = CSVFormat.EXCEL\n                .withIgnoreSurroundingSpaces(true)\n                .withQuoteMode(QuoteMode.ALL);\n        StringBuffer buffer = new StringBuffer();\n        CSVPrinter printer = new CSVPrinter(buffer, format);\n        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n        Assert.assertEquals(\",\\\"Hello\\\",,\\\"World\\\"\\r\\n\", buffer.toString());\n    }\n    @Test\n    public void testWithEmptyValues() throws Exception {\n        CSVFormat format = CSVFormat.EXCEL\n                .withNullString(\"N/A\")\n                .withIgnoreSurroundingSpaces(true)\n                .withQuoteMode(QuoteMode.ALL);\n        StringBuffer buffer = new StringBuffer();\n        CSVPrinter printer = new CSVPrinter(buffer, format);\n        printer.printRecord(new Object[] { \"\", \"Hello\", \"\", \"World\" });\n        Assert.assertEquals(\"\\\"\\\",\\\"Hello\\\",\\\"\\\",\\\"World\\\"\\r\\n\", buffer.toString());\n    }\n}"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                950,
                951,
                952,
                953,
                954,
                955,
                956,
                957,
                958,
                1043
            ],
            "src/main/java/org/apache/commons/csv/QuoteMode.java": [
                34
            ],
            "src/test/java/org/apache/commons/csv/issues/JiraCsv203Test.java": [
                1,
                3,
                4,
                5,
                6,
                7,
                12,
                14,
                15,
                16,
                17,
                18,
                19,
                21,
                22,
                23,
                25,
                26,
                28,
                29,
                30,
                31,
                32,
                33,
                35,
                36,
                37,
                39,
                40,
                42,
                43,
                44,
                45,
                46,
                48,
                49,
                50,
                52,
                53,
                55,
                56,
                57,
                58,
                59,
                60,
                62,
                63,
                64,
                66,
                67,
                69,
                70,
                71,
                72,
                73,
                74,
                76,
                77,
                78,
                80,
                81,
                83,
                84,
                85,
                87,
                88,
                90,
                91,
                92,
                94,
                95,
                97,
                98,
                99,
                100,
                101,
                102,
                104,
                105,
                106,
                109,
                110,
                111
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "            charSequence = nullString == null ? Constants.EMPTY : nullString;\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                949
            ]
        }
    },
    {
        "commit": "74afb17d",
        "prev_commit": "48068091",
        "changed_files": [
            "src/changes/changes.xml",
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/test/java/org/apache/commons/csv/CSVFormatPredefinedTest.java",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java"
        ],
        "changed_files_num": 4,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/test/java/org/apache/commons/csv/CSVFormatPredefinedTest.java",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java"
        ],
        "changed_java_files_num": 3,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "CSVParserTest",
            "JiraCsv203Test",
            "JiraCsv198Test",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 7,
            "CSVFormatTest": 47,
            "CSVParserTest": 69,
            "CSVPrinterTest": 81,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1,
            "JiraCsv198Test": 1,
            "JiraCsv203Test": 7
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+      <action issue=\"CSV-207\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Provide a CSV Format for printing PostgreSQL CSV and Text formats.</action>\n+        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n+        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n+    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n+    \t\t.withDelimiter(COMMA)\n+    \t\t.withEscape(DOUBLE_QUOTE_CHAR)\n+    \t\t.withIgnoreEmptyLines(false)\n+            .withQuote(DOUBLE_QUOTE_CHAR)\n+            .withRecordSeparator(LF)\n+            .withNullString(EMPTY)\n+    \t\t.withQuoteMode(QuoteMode.ALL_NON_NULL);\n+    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n+    \t\t.withDelimiter(TAB)\n+    \t\t.withEscape(DOUBLE_QUOTE_CHAR)\n+    \t\t.withIgnoreEmptyLines(false)\n+            .withQuote(DOUBLE_QUOTE_CHAR)\n+            .withRecordSeparator(LF)\n+            .withNullString(\"\\\\N\")\n+    \t\t.withQuoteMode(QuoteMode.ALL_NON_NULL);\n+    private void test(final CSVFormat format, final String enumName) {\n+        Assert.assertEquals(format, CSVFormat.Predefined.valueOf(enumName).getFormat());\n+        Assert.assertEquals(format, CSVFormat.valueOf(enumName));\n+    }\n+    @Test\n+    public void testDefault() {\n+        test(CSVFormat.DEFAULT, \"Default\");\n+    }\n+    @Test\n+    public void testExcel() {\n+        test(CSVFormat.EXCEL, \"Excel\");\n+    }\n+    @Test\n+    public void testMySQL() {\n+        test(CSVFormat.MYSQL, \"MySQL\");\n+    }\n+    @Test\n+    public void testPostgreSqlCsv() {\n+        test(CSVFormat.POSTGRESQL_CSV, \"PostgreSQLCsv\");\n+    }\n+    @Test\n+    public void testPostgreSqlText() {\n+        test(CSVFormat.POSTGRESQL_TEXT, \"PostgreSQLText\");\n+    }\n+    @Test\n+    public void testRFC4180() {\n+        test(CSVFormat.RFC4180, \"RFC4180\");\n+    }\n+    @Test\n+    public void testTDF() {\n+        test(CSVFormat.TDF, \"TDF\");\n+    }\n+    @Test\n+    @Ignore\n+    public void testPostgreSqlCsvNullOutput() throws IOException {\n+        Object[] s = new String[] { \"NULL\", null };\n+        CSVFormat format = CSVFormat.POSTGRESQL_CSV.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\n+        StringWriter writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        String expected = \"\\\"NULL\\\",NULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(new Object[2], record0);\n+        s = new String[] { \"\\\\N\", null };\n+        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"\\\\N\", \"A\" };\n+        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"\\n\", \"A\" };\n+        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\n\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"NULL\");\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.POSTGRESQL_CSV;\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_CSV;\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"NULL\", \"\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_CSV;\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_CSV;\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+    }\n+    @Test\n+    @Ignore\n+    public void testPostgreSqlCsvTextOutput() throws IOException {\n+        Object[] s = new String[] { \"NULL\", null };\n+        CSVFormat format = CSVFormat.POSTGRESQL_TEXT.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\n+        StringWriter writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        String expected = \"\\\"NULL\\\"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(new Object[2], record0);\n+        s = new String[] { \"\\\\N\", null };\n+        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"\\\\N\", \"A\" };\n+        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"\\n\", \"A\" };\n+        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\n\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"NULL\");\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.POSTGRESQL_TEXT;\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_TEXT;\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"NULL\", \"\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_TEXT;\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+        s = new String[] { \"\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_TEXT;\n+        writer = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+    }\n+    @Test\n+    public void testPostgreSQLNullStringDefaultCsv() {\n+        assertEquals(\"\", CSVFormat.POSTGRESQL_CSV.getNullString());\n+    }\n+    @Test\n+    public void testPostgreSQLNullStringDefaultText() {\n+        assertEquals(\"\\\\N\", CSVFormat.POSTGRESQL_TEXT.getNullString());\n+    }\n+    @Test\n+    @Ignore\n+    public void testRandomPostgreSqlCsv() throws Exception {\n+        doRandom(CSVFormat.POSTGRESQL_CSV, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+    @Test\n+    @Ignore\n+    public void testRandomPostgreSqlText() throws Exception {\n+        doRandom(CSVFormat.POSTGRESQL_TEXT, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "import static org.apache.commons.csv.Constants.EMPTY;\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n    \t\t.withDelimiter(COMMA)\n    \t\t.withEscape(DOUBLE_QUOTE_CHAR)\n    \t\t.withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n    \t\t.withQuoteMode(QuoteMode.ALL_NON_NULL);\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n    \t\t.withDelimiter(TAB)\n    \t\t.withEscape(DOUBLE_QUOTE_CHAR)\n    \t\t.withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n    \t\t.withQuoteMode(QuoteMode.ALL_NON_NULL);\n",
            "src/test/java/org/apache/commons/csv/CSVFormatPredefinedTest.java": "package org.apache.commons.csv;\nimport org.junit.Assert;\nimport org.junit.Test;\npublic class CSVFormatPredefinedTest {\n    private void test(final CSVFormat format, final String enumName) {\n        Assert.assertEquals(format, CSVFormat.Predefined.valueOf(enumName).getFormat());\n        Assert.assertEquals(format, CSVFormat.valueOf(enumName));\n    }\n    @Test\n    public void testDefault() {\n        test(CSVFormat.DEFAULT, \"Default\");\n    }\n    @Test\n    public void testExcel() {\n        test(CSVFormat.EXCEL, \"Excel\");\n    }\n    @Test\n    public void testMySQL() {\n        test(CSVFormat.MYSQL, \"MySQL\");\n    }\n    @Test\n    public void testPostgreSqlCsv() {\n        test(CSVFormat.POSTGRESQL_CSV, \"PostgreSQLCsv\");\n    }\n    @Test\n    public void testPostgreSqlText() {\n        test(CSVFormat.POSTGRESQL_TEXT, \"PostgreSQLText\");\n    }\n    @Test\n    public void testRFC4180() {\n        test(CSVFormat.RFC4180, \"RFC4180\");\n    }\n    @Test\n    public void testTDF() {\n        test(CSVFormat.TDF, \"TDF\");\n    }\n}\n",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": "    @Test\n    @Ignore\n    public void testPostgreSqlCsvNullOutput() throws IOException {\n        Object[] s = new String[] { \"NULL\", null };\n        CSVFormat format = CSVFormat.POSTGRESQL_CSV.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\n        StringWriter writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        String expected = \"\\\"NULL\\\",NULL\\n\";\n        assertEquals(expected, writer.toString());\n        String[] record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(new Object[2], record0);\n        s = new String[] { \"\\\\N\", null };\n        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\\\\\\\N\\t\\\\N\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"\\\\N\", \"A\" };\n        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\\\\\\\N\\tA\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"\\n\", \"A\" };\n        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\\\n\\tA\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"\", null };\n        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"NULL\");\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\tNULL\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"\", null };\n        format = CSVFormat.POSTGRESQL_CSV;\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\t\\\\N\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n        format = CSVFormat.POSTGRESQL_CSV;\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"NULL\", \"\\\\\\r\" };\n        format = CSVFormat.POSTGRESQL_CSV;\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"\\\\\\r\" };\n        format = CSVFormat.POSTGRESQL_CSV;\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\\\\\\\\\\\r\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n    }\n    @Test\n    @Ignore\n    public void testPostgreSqlCsvTextOutput() throws IOException {\n        Object[] s = new String[] { \"NULL\", null };\n        CSVFormat format = CSVFormat.POSTGRESQL_TEXT.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\n        StringWriter writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        String expected = \"\\\"NULL\\\"\\tNULL\\n\";\n        assertEquals(expected, writer.toString());\n        String[] record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(new Object[2], record0);\n        s = new String[] { \"\\\\N\", null };\n        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\\\\\\\N\\t\\\\N\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"\\\\N\", \"A\" };\n        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\\\\\\\N\\tA\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"\\n\", \"A\" };\n        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\\\n\\tA\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"\", null };\n        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"NULL\");\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\tNULL\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"\", null };\n        format = CSVFormat.POSTGRESQL_TEXT;\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\t\\\\N\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n        format = CSVFormat.POSTGRESQL_TEXT;\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"NULL\", \"\\\\\\r\" };\n        format = CSVFormat.POSTGRESQL_TEXT;\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n        s = new String[] { \"\\\\\\r\" };\n        format = CSVFormat.POSTGRESQL_TEXT;\n        writer = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n            printer.printRecord(s);\n        }\n        expected = \"\\\\\\\\\\\\r\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n    }\n    @Test\n    public void testPostgreSQLNullStringDefaultCsv() {\n        assertEquals(\"\", CSVFormat.POSTGRESQL_CSV.getNullString());\n    }\n    @Test\n    public void testPostgreSQLNullStringDefaultText() {\n        assertEquals(\"\\\\N\", CSVFormat.POSTGRESQL_TEXT.getNullString());\n    }\n    @Test\n    @Ignore\n    public void testRandomPostgreSqlCsv() throws Exception {\n        doRandom(CSVFormat.POSTGRESQL_CSV, ITERATIONS_FOR_RANDOM_TEST);\n    }\n    @Test\n    @Ignore\n    public void testRandomPostgreSqlText() throws Exception {\n        doRandom(CSVFormat.POSTGRESQL_TEXT, ITERATIONS_FOR_RANDOM_TEST);\n    }\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                23,
                198,
                203,
                409,
                410,
                411,
                412,
                413,
                414,
                415,
                416,
                446,
                447,
                448,
                449,
                450,
                451,
                452,
                453
            ],
            "src/test/java/org/apache/commons/csv/CSVFormatPredefinedTest.java": [
                18,
                20,
                21,
                26,
                28,
                29,
                30,
                31,
                33,
                34,
                35,
                36,
                38,
                39,
                40,
                41,
                43,
                44,
                45,
                46,
                48,
                49,
                50,
                51,
                53,
                54,
                55,
                56,
                58,
                59,
                60,
                61,
                63,
                64,
                65,
                66,
                67
            ],
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": [
                716,
                717,
                718,
                719,
                720,
                721,
                722,
                723,
                724,
                725,
                726,
                727,
                728,
                730,
                731,
                732,
                733,
                734,
                735,
                736,
                737,
                738,
                739,
                741,
                742,
                743,
                744,
                745,
                746,
                747,
                748,
                749,
                750,
                752,
                753,
                754,
                755,
                756,
                757,
                758,
                759,
                760,
                761,
                763,
                764,
                765,
                766,
                767,
                768,
                769,
                770,
                771,
                772,
                774,
                775,
                776,
                777,
                778,
                779,
                780,
                781,
                782,
                783,
                785,
                786,
                787,
                788,
                789,
                790,
                791,
                792,
                793,
                794,
                796,
                797,
                798,
                799,
                800,
                801,
                802,
                803,
                804,
                805,
                807,
                808,
                809,
                810,
                811,
                812,
                813,
                814,
                815,
                816,
                817,
                819,
                820,
                821,
                822,
                823,
                824,
                825,
                826,
                827,
                828,
                829,
                830,
                831,
                833,
                834,
                835,
                836,
                837,
                838,
                839,
                840,
                841,
                842,
                844,
                845,
                846,
                847,
                848,
                849,
                850,
                851,
                852,
                853,
                855,
                856,
                857,
                858,
                859,
                860,
                861,
                862,
                863,
                864,
                866,
                867,
                868,
                869,
                870,
                871,
                872,
                873,
                874,
                875,
                877,
                878,
                879,
                880,
                881,
                882,
                883,
                884,
                885,
                886,
                888,
                889,
                890,
                891,
                892,
                893,
                894,
                895,
                896,
                897,
                899,
                900,
                901,
                902,
                903,
                904,
                905,
                906,
                907,
                908,
                910,
                911,
                912,
                913,
                914,
                915,
                916,
                917,
                918,
                919,
                920,
                927,
                928,
                929,
                930,
                932,
                933,
                934,
                935,
                1167,
                1168,
                1169,
                1170,
                1171,
                1173,
                1174,
                1175,
                1176,
                1177
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/test/java/org/apache/commons/csv/CSVFormatPredefinedTest.java": "package org.apache.commons.csv;\nimport org.junit.Assert;\nimport org.junit.Test;\npublic class CSVFormatPredefinedTest {\n    private void test(final CSVFormat format, final String enumName) {\n        Assert.assertEquals(format, CSVFormat.Predefined.valueOf(enumName).getFormat());\n        Assert.assertEquals(format, CSVFormat.valueOf(enumName));\n    }\n    @Test\n    public void testDefault() {\n        test(CSVFormat.DEFAULT, \"Default\");\n    }\n    @Test\n    public void testExcel() {\n        test(CSVFormat.EXCEL, \"Excel\");\n    }\n    @Test\n    public void testMySQL() {\n        test(CSVFormat.MYSQL, \"MySQL\");\n    }\n    @Test\n    public void testRFC4180() {\n        test(CSVFormat.RFC4180, \"RFC4180\");\n    }\n    @Test\n    public void testTDF() {\n        test(CSVFormat.TDF, \"TDF\");\n    }\n}\n"
        },
        "deleted_line_number_list_per_file": {
            "src/test/java/org/apache/commons/csv/CSVFormatPredefinedTest.java": [
                18,
                20,
                21,
                26,
                28,
                29,
                30,
                31,
                33,
                34,
                35,
                36,
                38,
                39,
                40,
                41,
                43,
                44,
                45,
                46,
                48,
                49,
                50,
                51,
                53,
                54,
                55,
                56,
                57
            ]
        }
    },
    {
        "commit": "7e471527",
        "prev_commit": "10977ae1",
        "changed_files": [
            "pom.xml",
            "src/changes/changes.xml",
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/main/java/org/apache/commons/csv/CSVPrinter.java",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java"
        ],
        "changed_files_num": 5,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/main/java/org/apache/commons/csv/CSVPrinter.java",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java"
        ],
        "changed_java_files_num": 3,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "CSVParserTest",
            "JiraCsv203Test",
            "JiraCsv213Test",
            "JiraCsv198Test",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 7,
            "CSVFormatTest": 55,
            "CSVParserTest": 72,
            "CSVPrinterTest": 89,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1,
            "JiraCsv198Test": 1,
            "JiraCsv203Test": 7,
            "JiraCsv213Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-all</artifactId>\n+      <version>1.9.5</version>\n+      <scope>test</scope>\n+    </dependency>\n+      <action issue=\"CSV-217\" type=\"add\" dev=\"ggregory\" due-to=\"Korolyov Alexei\">Add autoFlush option for CsvPrinter. PR #24.</action>\n+            null, null, null, false, false, false, false, false, false);\n+                false, false, false, false);\n+    private final boolean autoFlush;\n+                      final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n+                      final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n+                      final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n+                      final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n+                      final boolean trailingDelimiter, boolean autoFlush) {\n+        this.autoFlush = autoFlush;\n+    public boolean getAutoFlush() {\n+        return autoFlush;\n+    }\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+    }\n+    public CSVFormat withAutoFlush(final boolean autoFlush) {\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+            ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n+            skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+        close(false);\n+    }\n+    public void close(boolean flush) throws IOException {\n+        if (flush || format.getAutoFlush()) {\n+            if (out instanceof Flushable) {\n+                ((Flushable) out).flush();\n+            }\n+        }\n+    @Test\n+    public void testCloseWithFlushOn() throws IOException {\n+        Writer writer = mock(Writer.class);\n+        CSVFormat csvFormat = CSVFormat.DEFAULT;\n+        CSVPrinter csvPrinter = new CSVPrinter(writer, csvFormat);\n+        csvPrinter.close(true);\n+        verify(writer, times(1)).flush();\n+    }\n+    @Test\n+    public void testCloseWithFlushOff() throws IOException {\n+        Writer writer = mock(Writer.class);\n+        CSVFormat csvFormat = CSVFormat.DEFAULT;\n+        CSVPrinter csvPrinter = new CSVPrinter(writer, csvFormat);\n+        csvPrinter.close(false);\n+        verify(writer, never()).flush();\n+        verify(writer, times(1)).close();\n+    }\n+    @Test\n+    public void testCloseBackwardCompatibility() throws IOException {\n+        Writer writer = mock(Writer.class);\n+        CSVFormat csvFormat = CSVFormat.DEFAULT;\n+        try (CSVPrinter csvPrinter = new CSVPrinter(writer, csvFormat)) {\n+        }\n+        verify(writer, never()).flush();\n+        verify(writer, times(1)).close();\n+    }\n+    @Test\n+    public void testCloseWithCsvFormatAutoFlushOn() throws IOException {\n+        System.out.println(\"start method\");\n+        Writer writer = mock(Writer.class);\n+        CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(true);\n+        try (CSVPrinter csvPrinter = new CSVPrinter(writer, csvFormat)) {\n+        }\n+        verify(writer, times(1)).flush();\n+        verify(writer, times(1)).close();\n+    }\n+    @Test\n+    public void testCloseWithCsvFormatAutoFlushOff() throws IOException {\n+        Writer writer = mock(Writer.class);\n+        CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(false);\n+        try (CSVPrinter csvPrinter = new CSVPrinter(writer, csvFormat)) {\n+        }\n+        verify(writer, never()).flush();\n+        verify(writer, times(1)).close();\n+    }\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "            null, null, null, false, false, false, false, false, false);\n                false, false, false, false);\n    private final boolean autoFlush;\n                      final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n                      final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n                      final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n                      final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n                      final boolean trailingDelimiter, boolean autoFlush) {\n        this.autoFlush = autoFlush;\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n            ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n            skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n",
            "src/main/java/org/apache/commons/csv/CSVPrinter.java": "        close(false);\n    }\n    public void close(boolean flush) throws IOException {\n        if (flush || format.getAutoFlush()) {\n            if (out instanceof Flushable) {\n                ((Flushable) out).flush();\n            }\n        }\n",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": "import static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport java.io.Writer;\n    @Test\n    public void testCloseWithFlushOn() throws IOException {\n        Writer writer = mock(Writer.class);\n        CSVFormat csvFormat = CSVFormat.DEFAULT;\n        CSVPrinter csvPrinter = new CSVPrinter(writer, csvFormat);\n        csvPrinter.close(true);\n        verify(writer, times(1)).flush();\n    }\n    @Test\n    public void testCloseWithFlushOff() throws IOException {\n        Writer writer = mock(Writer.class);\n        CSVFormat csvFormat = CSVFormat.DEFAULT;\n        CSVPrinter csvPrinter = new CSVPrinter(writer, csvFormat);\n        csvPrinter.close(false);\n        verify(writer, never()).flush();\n        verify(writer, times(1)).close();\n    }\n    @Test\n    public void testCloseBackwardCompatibility() throws IOException {\n        Writer writer = mock(Writer.class);\n        CSVFormat csvFormat = CSVFormat.DEFAULT;\n        try (CSVPrinter csvPrinter = new CSVPrinter(writer, csvFormat)) {\n        }\n        verify(writer, never()).flush();\n        verify(writer, times(1)).close();\n    }\n    @Test\n    public void testCloseWithCsvFormatAutoFlushOn() throws IOException {\n        System.out.println(\"start method\");\n        Writer writer = mock(Writer.class);\n        CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(true);\n        try (CSVPrinter csvPrinter = new CSVPrinter(writer, csvFormat)) {\n        }\n        verify(writer, times(1)).flush();\n        verify(writer, times(1)).close();\n    }\n    @Test\n    public void testCloseWithCsvFormatAutoFlushOff() throws IOException {\n        Writer writer = mock(Writer.class);\n        CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(false);\n        try (CSVPrinter csvPrinter = new CSVPrinter(writer, csvFormat)) {\n        }\n        verify(writer, never()).flush();\n        verify(writer, times(1)).close();\n    }\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                245,
                540,
                587,
                629,
                630,
                631,
                632,
                633,
                650,
                900,
                901,
                902,
                1448,
                1483,
                1501,
                1532,
                1687,
                1708,
                1733,
                1759,
                1784,
                1803,
                1834,
                1848,
                1886,
                1913,
                1938,
                1963,
                1964,
                1975,
                1976,
                1977,
                1978
            ],
            "src/main/java/org/apache/commons/csv/CSVPrinter.java": [
                84,
                85,
                95,
                96,
                97,
                98,
                99,
                100
            ],
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": [
                24,
                25,
                26,
                27,
                34,
                1319,
                1320,
                1321,
                1322,
                1323,
                1324,
                1325,
                1326,
                1328,
                1329,
                1330,
                1331,
                1332,
                1333,
                1334,
                1335,
                1336,
                1338,
                1339,
                1340,
                1341,
                1342,
                1343,
                1344,
                1345,
                1346,
                1348,
                1349,
                1350,
                1351,
                1352,
                1353,
                1354,
                1355,
                1356,
                1357,
                1359,
                1360,
                1361,
                1362,
                1363,
                1364,
                1365,
                1366,
                1367
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "            null, null, null, false, false, false, false, false);\n                false, false, false);\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                245,
                540,
                626,
                627,
                628,
                629,
                630,
                1434,
                1469,
                1487,
                1518,
                1673,
                1694,
                1719,
                1745,
                1770,
                1789,
                1820,
                1834,
                1872,
                1899,
                1924,
                1949
            ]
        }
    },
    {
        "commit": "cf1460b2",
        "prev_commit": "4901f1cc",
        "changed_files": [
            "src/main/java/org/apache/commons/csv/CSVParser.java"
        ],
        "changed_files_num": 1,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVParser.java"
        ],
        "changed_java_files_num": 1,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "FercGovTest",
            "CSVParserTest",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 5,
            "CSVFormatTest": 45,
            "CSVParserTest": 67,
            "CSVPrinterTest": 61,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "FercGovTest": 2,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": "                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": [
                406
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": "                    if (containsHeader &&\n                            (!emptyHeader || (emptyHeader && !this.format.getAllowMissingColumnNames()))) {\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": [
                406,
                407
            ]
        }
    },
    {
        "commit": "f368f64f",
        "prev_commit": "33f662b2",
        "changed_files": [
            "src/changes/changes.xml",
            "src/main/java/org/apache/commons/csv/CSVParser.java",
            "src/test/java/org/apache/commons/csv/CSVParserTest.java"
        ],
        "changed_files_num": 3,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVParser.java",
            "src/test/java/org/apache/commons/csv/CSVParserTest.java"
        ],
        "changed_java_files_num": 2,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "CSVParserTest",
            "JiraCsv203Test",
            "JiraCsv213Test",
            "JiraCsv198Test",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 8,
            "CSVFormatTest": 56,
            "CSVParserTest": 73,
            "CSVPrinterTest": 91,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1,
            "JiraCsv198Test": 1,
            "JiraCsv203Test": 7,
            "JiraCsv213Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+      <action issue=\"CSV-224\" type=\"fix\" dev=\"ggregory\" due-to=\"David Warshaw\">Some Multi Iterator Parsing Peek Sequences Incorrectly Consume Elements.</action>\n+    private final CSVRecordIterator csvRecordIterator;\n+    \n+        this.csvRecordIterator = new CSVRecordIterator();\n+        return csvRecordIterator;\n+    }\n+    \n+    class CSVRecordIterator implements Iterator<CSVRecord> {\n+        private CSVRecord current;\n+  \n+        private CSVRecord getNextRecord() {\n+            try {\n+                return CSVParser.this.nextRecord();\n+            } catch (final IOException e) {\n+                throw new IllegalStateException(\n+                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n+        }\n+  \n+        @Override\n+        public boolean hasNext() {\n+            if (CSVParser.this.isClosed()) {\n+                return false;\n+            if (this.current == null) {\n+                this.current = this.getNextRecord();\n+            }\n+  \n+            return this.current != null;\n+        }\n+  \n+        @Override\n+        public CSVRecord next() {\n+            if (CSVParser.this.isClosed()) {\n+                throw new NoSuchElementException(\"CSVParser has been closed\");\n+            }\n+            CSVRecord next = this.current;\n+            this.current = null;\n+  \n+            if (next == null) {\n+                next = this.getNextRecord();\n+                    throw new NoSuchElementException(\"No more CSV records available\");\n+  \n+            return next;\n+        }\n+  \n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n+    @Test\n+    public void testIteratorSequenceBreaking() throws IOException {\n+        final String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\n+        CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n+        int recordNumber = 0;\n+        Iterator<CSVRecord> iter = parser.iterator();\n+        recordNumber = 0;\n+        while (iter.hasNext()) {\n+            CSVRecord record = iter.next();\n+            recordNumber++;\n+            assertEquals(String.valueOf(recordNumber), record.get(0));\n+            if (recordNumber >= 2) {\n+                break;\n+            }\n+        }\n+        iter.hasNext();\n+        while (iter.hasNext()) {\n+            CSVRecord record = iter.next();\n+            recordNumber++;\n+            assertEquals(String.valueOf(recordNumber), record.get(0));\n+        }\n+        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n+        recordNumber = 0;\n+        for (CSVRecord record : parser) {\n+            recordNumber++;\n+            assertEquals(String.valueOf(recordNumber), record.get(0));\n+            if (recordNumber >= 2) {\n+                break;\n+            }\n+        }\n+        for (CSVRecord record : parser) {\n+            recordNumber++;\n+            assertEquals(String.valueOf(recordNumber), record.get(0));\n+        }\n+        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n+        recordNumber = 0;\n+        for (CSVRecord record : parser) {\n+            recordNumber++;\n+            assertEquals(String.valueOf(recordNumber), record.get(0));\n+            if (recordNumber >= 2) {\n+                break;\n+            }\n+        }\n+        parser.iterator().hasNext();\n+        for (CSVRecord record : parser) {\n+            recordNumber++;\n+            assertEquals(String.valueOf(recordNumber), record.get(0));\n+        }\n+    }\n+    \n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": "    private final CSVRecordIterator csvRecordIterator;\n        this.csvRecordIterator = new CSVRecordIterator();\n        return csvRecordIterator;\n    }\n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n        }\n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n            return this.current != null;\n        }\n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n            if (next == null) {\n                next = this.getNextRecord();\n                    throw new NoSuchElementException(\"No more CSV records available\");\n            return next;\n        }\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n",
            "src/test/java/org/apache/commons/csv/CSVParserTest.java": "    @Test\n    public void testIteratorSequenceBreaking() throws IOException {\n        final String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\n        CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n        int recordNumber = 0;\n        Iterator<CSVRecord> iter = parser.iterator();\n        recordNumber = 0;\n        while (iter.hasNext()) {\n            CSVRecord record = iter.next();\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n            if (recordNumber >= 2) {\n                break;\n            }\n        }\n        iter.hasNext();\n        while (iter.hasNext()) {\n            CSVRecord record = iter.next();\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n        }\n        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n        recordNumber = 0;\n        for (CSVRecord record : parser) {\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n            if (recordNumber >= 2) {\n                break;\n            }\n        }\n        for (CSVRecord record : parser) {\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n        }\n        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n        recordNumber = 0;\n        for (CSVRecord record : parser) {\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n            if (recordNumber >= 2) {\n                break;\n            }\n        }\n        parser.iterator().hasNext();\n        for (CSVRecord record : parser) {\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n        }\n    }\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": [
                289,
                358,
                525,
                526,
                528,
                529,
                531,
                532,
                533,
                534,
                535,
                536,
                538,
                540,
                541,
                542,
                543,
                545,
                546,
                547,
                549,
                550,
                552,
                553,
                554,
                555,
                556,
                557,
                558,
                560,
                562,
                564,
                568,
                569,
                571,
                572,
                573,
                574,
                575
            ],
            "src/test/java/org/apache/commons/csv/CSVParserTest.java": [
                992,
                993,
                994,
                997,
                998,
                999,
                1000,
                1001,
                1002,
                1003,
                1004,
                1005,
                1006,
                1007,
                1008,
                1009,
                1010,
                1011,
                1012,
                1013,
                1014,
                1017,
                1018,
                1019,
                1020,
                1021,
                1022,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1032,
                1033,
                1034,
                1035,
                1036,
                1037,
                1038,
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": "        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    throw new IllegalStateException(\n                            e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n                }\n            @Override\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n                return this.current != null;\n            @Override\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                return next;\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVParser.java": [
                522,
                523,
                525,
                526,
                527,
                528,
                529,
                530,
                531,
                534,
                535,
                536,
                537,
                538,
                539,
                540,
                541,
                543,
                546,
                547,
                548,
                549,
                550,
                551,
                552,
                556,
                557,
                558,
                559,
                562,
                565,
                566,
                567,
                568,
                569,
                570
            ]
        }
    },
    {
        "commit": "16b9e2c7",
        "prev_commit": "10399508",
        "changed_files": [
            "src/changes/changes.xml",
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/main/java/org/apache/commons/csv/CSVParser.java",
            "src/main/java/org/apache/commons/csv/CSVPrinter.java",
            "src/test/java/org/apache/commons/csv/CSVParserTest.java",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java"
        ],
        "changed_files_num": 6,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/main/java/org/apache/commons/csv/CSVParser.java",
            "src/main/java/org/apache/commons/csv/CSVPrinter.java",
            "src/test/java/org/apache/commons/csv/CSVParserTest.java",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java"
        ],
        "changed_java_files_num": 5,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "FercGovTest",
            "CSVParserTest",
            "CSVFormatTest",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 5,
            "CSVFormatTest": 44,
            "CSVParserTest": 67,
            "CSVPrinterTest": 61,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "FercGovTest": 2,
            "JiraCsv167Test": 1,
            "LexerTest": 26,
            "TokenMatchersTest": 4
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+      <action issue=\"CSV-168\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, cornel creanga\">CSVFormat.nullString should not be escaped</action>\n+      <action issue=\"CSV-175\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, Chris Jones\">Support for ignoring trailing delimiter.</action>\n+      <action issue=\"CSV-177\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Support trimming leading and trailing blanks.</action>\n+      <action issue=\"CSV-178\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Create default formats for Informix UNLOAD and UNLOAD CSV.</action>\n+        Default(CSVFormat.DEFAULT),\n+        Excel(CSVFormat.EXCEL),\n+        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n+        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n+        MySQL(CSVFormat.MYSQL),\n+    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n+            null, null, null, false, false, false, false, false);\n+    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH)\n+            .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF);\n+    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR)\n+            .withRecordSeparator(LF);\n+        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n+                false, false, false);\n+    private final boolean trailingDelimiter;\n+    private final boolean trim;\n+            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, boolean trim, boolean trailingDelimiter) {\n+        this.trailingDelimiter = trailingDelimiter;\n+        this.trim = trim;        \n+    public boolean getTrailingDelimiter() {\n+        return trailingDelimiter;\n+    }\n+    public boolean getTrim() {\n+        return trim;\n+    }\n+            throw new IllegalArgumentException(\n+                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n+            throw new IllegalArgumentException(\n+                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n+            throw new IllegalArgumentException(\n+                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n+            throw new IllegalArgumentException(\n+                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n+            throw new IllegalArgumentException(\n+                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n+                    throw new IllegalArgumentException(\n+                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+    }\n+    public CSVFormat withTrim(final boolean trim) {\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+    }\n+    public CSVFormat withTrailingDelimiter() {\n+        return withTrailingDelimiter(true);\n+    }\n+    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+    }\n+    public CSVFormat withTrim() {\n+        return withTrim(true);\n+    private void addRecordValue(boolean lastRecord) {\n+        final String inputClean = this.format.getTrim() ? input.trim() : input;\n+        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n+            return;\n+        }\n+        this.record.add(inputClean.equals(nullString) ? null : inputClean);\n+                this.addRecordValue(false);\n+                this.addRecordValue(true);\n+                    this.addRecordValue(true);\n+        strValue = format.getTrim() ? strValue.trim() : strValue;\n+        if (format.getTrailingDelimiter()) {\n+            out.append(format.getDelimiter());            \n+        }\n+    @Test\n+    public void testTrailingDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a,a,a,\\n\\\"1\\\",\\\"2\\\",\\\"3\\\",\\nx,y,z,\");\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrailingDelimiter()\n+                .parse(in).iterator();\n+        final CSVRecord record = records.next();\n+        assertEquals(\"1\", record.get(\"X\"));\n+        assertEquals(\"2\", record.get(\"Y\"));\n+        assertEquals(\"3\", record.get(\"Z\"));\n+        Assert.assertEquals(3, record.size());\n+    }\n+    @Test\n+    public void testTrim() throws Exception {\n+        final Reader in = new StringReader(\"a,a,a\\n\\\" 1 \\\",\\\" 2 \\\",\\\" 3 \\\"\\nx,y,z\");\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrim()\n+                .parse(in).iterator();\n+        final CSVRecord record = records.next();\n+        assertEquals(\"1\", record.get(\"X\"));\n+        assertEquals(\"2\", record.get(\"Y\"));\n+        assertEquals(\"3\", record.get(\"Z\"));\n+        Assert.assertEquals(3, record.size());\n+    }\n+    private final String recordSeparator = CSVFormat.DEFAULT.getRecordSeparator();\n+    private void doRandom(final CSVFormat format, final int iter) throws Exception {\n+        for (int i = 0; i < iter; i++) {\n+            doOneRandom(format);\n+        }\n+    }\n+    private <T> T[] expectNulls(final T[] original, final CSVFormat csvFormat) {\n+        final T[] fixed = original.clone();\n+        for (int i = 0; i < fixed.length; i++) {\n+            if (ObjectUtils.equals(csvFormat.getNullString(), fixed[i])) {\n+                fixed[i] = null;\n+            }\n+        }\n+        return fixed;\n+    }\n+    private Connection geH2Connection() throws SQLException, ClassNotFoundException {\n+        Class.forName(\"org.h2.Driver\");\n+        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n+    }\n+    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat)\n+            throws IOException {\n+        CSVFormat format = baseFormat;\n+        format = format.withHeaderComments(\"Generated by Apache Commons CSV 1.1\", now);\n+        format = format.withCommentMarker('#');\n+        format = format.withHeader(\"Col1\", \"Col2\");\n+        final CSVPrinter csvPrinter = format.print(sw);\n+        csvPrinter.printRecord(\"A\", \"B\");\n+        csvPrinter.printRecord(\"C\", \"D\");\n+        csvPrinter.close();\n+        return csvPrinter;\n+    private void setUpTable(final Connection connection) throws SQLException {\n+        final Statement statement = connection.createStatement();\n+        try {\n+            statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n+            statement.execute(\"insert into TEST values(1, 'r1')\");\n+            statement.execute(\"insert into TEST values(2, 'r2')\");\n+        } finally {\n+            statement.close();\n+        }\n+    }\n+    @Test\n+    public void testDelimeterQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n+        printer.print(\"a,b,c\");\n+        printer.print(\"xyz\");\n+        assertEquals(\"'a,b,c',xyz\", sw.toString());\n+        printer.close();\n+    }\n+    @Test\n+    public void testDelimeterQuoteNONE() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuoteMode(QuoteMode.NONE);\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n+        printer.print(\"a,b,c\");\n+        printer.print(\"xyz\");\n+        assertEquals(\"a!,b!,c,xyz\", sw.toString());\n+        printer.close();\n+    }\n+    @Test\n+    public void testDelimiterEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null));\n+        printer.print(\"a,b,c\");\n+        printer.print(\"xyz\");\n+        assertEquals(\"a!,b!,c,xyz\", sw.toString());\n+        printer.close();\n+    }\n+    @Test\n+    public void testDelimiterPlain() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n+        printer.print(\"a,b,c\");\n+        printer.print(\"xyz\");\n+        assertEquals(\"a,b,c,xyz\", sw.toString());\n+        printer.close();\n+    }\n+    \n+    @Test\n+    public void testEOLEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n+        printer.print(\"a\\rb\\nc\");\n+        printer.print(\"x\\fy\\bz\");\n+        assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\n+        printer.close();\n+    }\n+    \n+    @Test\n+    public void testEOLPlain() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n+        printer.print(\"a\\rb\\nc\");\n+        printer.print(\"x\\fy\\bz\");\n+        assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\n+        printer.close();\n+    }\n+    \n+    @Test\n+    public void testEOLQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n+        printer.print(\"a\\rb\\nc\");\n+        printer.print(\"x\\by\\fz\");\n+        assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\n+        printer.close();\n+    }\n+    \n+    @Test\n+    public void testEscapeBackslash() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        final char quoteChar = '\\'';\n+        final String eol = \"\\r\\n\";\n+        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n+        printer.print(\"\\\\\");\n+        printer.close();\n+        assertEquals(\"'\\\\'\", sw.toString());\n+        sw = new StringWriter();\n+        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n+        printer.print(\"\\\\\\r\");\n+        printer.close();\n+        assertEquals(\"'\\\\\\r'\", sw.toString());\n+        sw = new StringWriter();\n+        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n+        printer.print(\"X\\\\\\r\");\n+        printer.close();\n+        assertEquals(\"'X\\\\\\r'\", sw.toString());\n+        sw = new StringWriter();\n+        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n+        printer.printRecord(new Object[] { \"\\\\\\r\" });\n+        printer.close();\n+        assertEquals(\"'\\\\\\r'\" + eol, sw.toString());\n+        sw = new StringWriter();\n+        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n+        printer.print(\"\\\\\\\\\");\n+        printer.close();\n+        assertEquals(\"'\\\\\\\\'\", sw.toString());\n+    }\n+    public void testHeader() throws IOException {\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\"));\n+        printer.printRecord(\"a\", \"b\", \"c\");\n+        printer.printRecord(\"x\", \"y\", \"z\");\n+        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+    public void testHeaderCommentExcel() throws IOException {\n+        final Date now = new Date();\n+        final CSVFormat format = CSVFormat.EXCEL;\n+        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n+        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\",\n+                sw.toString());\n+        csvPrinter.close();\n+    public void testHeaderCommentTdf() throws IOException {\n+        final Date now = new Date();\n+        final CSVFormat format = CSVFormat.TDF;\n+        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n+        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\",\n+                sw.toString());\n+        csvPrinter.close();\n+    public void testHeaderNotSet() throws IOException {\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n+        printer.printRecord(\"a\", \"b\", \"c\");\n+        printer.printRecord(\"x\", \"y\", \"z\");\n+        assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testInvalidFormat() throws Exception {\n+        final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n+        new CSVPrinter(new StringWriter(), invalidFormat).close();\n+    }\n+    @Test\n+    @Ignore\n+    public void testJira135_part1() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n+        final List<String> list = new LinkedList<String>();\n+        list.add(\"\\\"\");\n+        printer.printRecord(list);\n+        printer.close();\n+        final String expected = \"\\\"\\\\\\\"\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+    @Test\n+    @Ignore\n+    public void testJira135_part2() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n+        final List<String> list = new LinkedList<String>();\n+        list.add(\"\\n\");\n+        printer.printRecord(list);\n+        printer.close();\n+        final String expected = \"\\\"\\\\n\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+    @Test\n+    @Ignore\n+    public void testJira135_part3() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n+        final List<String> list = new LinkedList<String>();\n+        list.add(\"\\\\\");\n+        printer.printRecord(list);\n+        printer.close();\n+        final String expected = \"\\\"\\\\\\\\\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+    @Test\n+    @Ignore\n+    public void testJira135All() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n+        final List<String> list = new LinkedList<String>();\n+        list.add(\"\\\"\");\n+        list.add(\"\\n\");\n+        list.add(\"\\\\\");\n+        printer.printRecord(list);\n+        printer.close();\n+        final String expected = \"\\\"\\\\\\\"\\\",\\\"\\\\n\\\",\\\"\\\\\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    @Test\n+    public void testMySqlNullStringDefault() throws IOException {\n+        assertEquals(\"\\\\N\", CSVFormat.MYSQL.getNullString());\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testNewCsvPrinterAppendableNullFormat() throws Exception {\n+        new CSVPrinter(new StringWriter(), null).close();\n+    }\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testNewCSVPrinterNullAppendableFormat() throws Exception {\n+        new CSVPrinter(null, CSVFormat.DEFAULT).close();\n+    }\n+    @Test\n+    public void testParseCustomNullValues() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVFormat format = CSVFormat.DEFAULT.withNullString(\"NULL\");\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n+        printer.printRecord(\"a\", null, \"b\");\n+        printer.close();\n+        final String csvString = sw.toString();\n+        assertEquals(\"a,NULL,b\" + recordSeparator, csvString);\n+        final Iterable<CSVRecord> iterable = format.parse(new StringReader(csvString));\n+        final Iterator<CSVRecord> iterator = iterable.iterator();\n+        final CSVRecord record = iterator.next();\n+        assertEquals(\"a\", record.get(0));\n+        assertEquals(null, record.get(1));\n+        assertEquals(\"b\", record.get(2));\n+        assertFalse(iterator.hasNext());\n+        ((CSVParser) iterable).close();\n+    }\n+    @Test\n+    public void testPlainEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n+        printer.print(\"abc\");\n+        printer.print(\"xyz\");\n+        assertEquals(\"abc,xyz\", sw.toString());\n+        printer.close();\n+    }\n+    @Test\n+    public void testPlainPlain() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n+        printer.print(\"abc\");\n+        printer.print(\"xyz\");\n+        assertEquals(\"abc,xyz\", sw.toString());\n+        printer.close();\n+    }\n+    @Test\n+    public void testPlainQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n+        printer.print(\"abc\");\n+        assertEquals(\"abc\", sw.toString());\n+        printer.close();\n+    }\n+    @Test\n+    public void testPrint() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = CSVFormat.DEFAULT.print(sw);\n+        printer.printRecord(\"a\", \"b\\\\c\");\n+        assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n+        printer.close();\n+    }\n+    @Test\n+    public void testPrintCustomNullValues() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"));\n+        printer.printRecord(\"a\", null, \"b\");\n+        assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\n+        printer.close();\n+    public void testRandomTdf() throws Exception {\n+        doRandom(CSVFormat.TDF, ITERATIONS_FOR_RANDOM_TEST);\n+    public void testSkipHeaderRecordFalse() throws IOException {\n+        final CSVPrinter printer = new CSVPrinter(sw,\n+                CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(false));\n+    public void testTrimOnOneColumn() throws IOException {\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim());\n+        printer.print(\" A \");\n+        assertEquals(\"A\", sw.toString());\n+    public void testTrimOnTwoColumns() throws IOException {\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim());\n+        printer.print(\" A \");\n+        printer.print(\" B \");\n+        assertEquals(\"A,B\", sw.toString());\n+        printer.close();\n+    public void testTrailingDelimiterOnTwoColumns() throws IOException {\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrailingDelimiter());\n+        printer.printRecord(\"A\", \"B\");\n+        assertEquals(\"A,B,\\r\\n\", sw.toString());\n+        printer.close();\n+    public void testTrimOffOneColumn() throws IOException {\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim(false));\n+        printer.print(\" A \");\n+        assertEquals(\"\\\" A \\\"\", sw.toString());\n+    private String[] toFirstRecordValues(final String expected, final CSVFormat format) throws IOException {\n+        return CSVParser.parse(expected, format).getRecords().get(0).values();\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "import static org.apache.commons.csv.Constants.PIPE;\n        Default(CSVFormat.DEFAULT),\n        Excel(CSVFormat.EXCEL),\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n        MySQL(CSVFormat.MYSQL),\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false);\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF);\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false);\n    private final boolean trailingDelimiter;\n    private final boolean trim;\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, boolean trim, boolean trailingDelimiter) {\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;        \n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n    public boolean getTrim() {\n        return trim;\n    }\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n    public CSVFormat withTrim() {\n        return withTrim(true);\n",
            "src/main/java/org/apache/commons/csv/CSVParser.java": "    private void addRecordValue(boolean lastRecord) {\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        this.record.add(inputClean.equals(nullString) ? null : inputClean);\n                this.addRecordValue(false);\n                this.addRecordValue(true);\n                    this.addRecordValue(true);\n",
            "src/main/java/org/apache/commons/csv/CSVPrinter.java": "        strValue = format.getTrim() ? strValue.trim() : strValue;\n        if (format.getTrailingDelimiter()) {\n            out.append(format.getDelimiter());            \n        }\n",
            "src/test/java/org/apache/commons/csv/CSVParserTest.java": "    @Test\n    public void testTrailingDelimiter() throws Exception {\n        final Reader in = new StringReader(\"a,a,a,\\n\\\"1\\\",\\\"2\\\",\\\"3\\\",\\nx,y,z,\");\n        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrailingDelimiter()\n                .parse(in).iterator();\n        final CSVRecord record = records.next();\n        assertEquals(\"1\", record.get(\"X\"));\n        assertEquals(\"2\", record.get(\"Y\"));\n        assertEquals(\"3\", record.get(\"Z\"));\n        Assert.assertEquals(3, record.size());\n    }\n    @Test\n    public void testTrim() throws Exception {\n        final Reader in = new StringReader(\"a,a,a\\n\\\" 1 \\\",\\\" 2 \\\",\\\" 3 \\\"\\nx,y,z\");\n        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrim()\n                .parse(in).iterator();\n        final CSVRecord record = records.next();\n        assertEquals(\"1\", record.get(\"X\"));\n        assertEquals(\"2\", record.get(\"Y\"));\n        assertEquals(\"3\", record.get(\"Z\"));\n        Assert.assertEquals(3, record.size());\n    }\n",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": "    private final String recordSeparator = CSVFormat.DEFAULT.getRecordSeparator();\n    private void doRandom(final CSVFormat format, final int iter) throws Exception {\n        for (int i = 0; i < iter; i++) {\n            doOneRandom(format);\n        }\n    }\n    private <T> T[] expectNulls(final T[] original, final CSVFormat csvFormat) {\n        final T[] fixed = original.clone();\n        for (int i = 0; i < fixed.length; i++) {\n            if (ObjectUtils.equals(csvFormat.getNullString(), fixed[i])) {\n                fixed[i] = null;\n            }\n        }\n        return fixed;\n    }\n    private Connection geH2Connection() throws SQLException, ClassNotFoundException {\n        Class.forName(\"org.h2.Driver\");\n        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n    }\n    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat)\n            throws IOException {\n        CSVFormat format = baseFormat;\n        format = format.withHeaderComments(\"Generated by Apache Commons CSV 1.1\", now);\n        format = format.withCommentMarker('#');\n        format = format.withHeader(\"Col1\", \"Col2\");\n        final CSVPrinter csvPrinter = format.print(sw);\n        csvPrinter.printRecord(\"A\", \"B\");\n        csvPrinter.printRecord(\"C\", \"D\");\n        csvPrinter.close();\n        return csvPrinter;\n    private void setUpTable(final Connection connection) throws SQLException {\n        final Statement statement = connection.createStatement();\n        try {\n            statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n            statement.execute(\"insert into TEST values(1, 'r1')\");\n            statement.execute(\"insert into TEST values(2, 'r2')\");\n        } finally {\n            statement.close();\n        }\n    }\n    @Test\n    public void testDelimeterQuoted() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n        printer.print(\"a,b,c\");\n        printer.print(\"xyz\");\n        assertEquals(\"'a,b,c',xyz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testDelimeterQuoteNONE() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuoteMode(QuoteMode.NONE);\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n        printer.print(\"a,b,c\");\n        printer.print(\"xyz\");\n        assertEquals(\"a!,b!,c,xyz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testDelimiterEscaped() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null));\n        printer.print(\"a,b,c\");\n        printer.print(\"xyz\");\n        assertEquals(\"a!,b!,c,xyz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testDelimiterPlain() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n        printer.print(\"a,b,c\");\n        printer.print(\"xyz\");\n        assertEquals(\"a,b,c,xyz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testEOLEscaped() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n        printer.print(\"a\\rb\\nc\");\n        printer.print(\"x\\fy\\bz\");\n        assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testEOLPlain() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n        printer.print(\"a\\rb\\nc\");\n        printer.print(\"x\\fy\\bz\");\n        assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testEOLQuoted() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n        printer.print(\"a\\rb\\nc\");\n        printer.print(\"x\\by\\fz\");\n        assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testEscapeBackslash() throws IOException {\n        StringWriter sw = new StringWriter();\n        final char quoteChar = '\\'';\n        final String eol = \"\\r\\n\";\n        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n        printer.print(\"\\\\\");\n        printer.close();\n        assertEquals(\"'\\\\'\", sw.toString());\n        sw = new StringWriter();\n        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n        printer.print(\"\\\\\\r\");\n        printer.close();\n        assertEquals(\"'\\\\\\r'\", sw.toString());\n        sw = new StringWriter();\n        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n        printer.print(\"X\\\\\\r\");\n        printer.close();\n        assertEquals(\"'X\\\\\\r'\", sw.toString());\n        sw = new StringWriter();\n        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n        printer.printRecord(new Object[] { \"\\\\\\r\" });\n        printer.close();\n        assertEquals(\"'\\\\\\r'\" + eol, sw.toString());\n        sw = new StringWriter();\n        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n        printer.print(\"\\\\\\\\\");\n        printer.close();\n        assertEquals(\"'\\\\\\\\'\", sw.toString());\n    }\n    public void testHeader() throws IOException {\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\"));\n        printer.printRecord(\"a\", \"b\", \"c\");\n        printer.printRecord(\"x\", \"y\", \"z\");\n        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n    public void testHeaderCommentExcel() throws IOException {\n        final Date now = new Date();\n        final CSVFormat format = CSVFormat.EXCEL;\n        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\",\n                sw.toString());\n        csvPrinter.close();\n    public void testHeaderCommentTdf() throws IOException {\n        final Date now = new Date();\n        final CSVFormat format = CSVFormat.TDF;\n        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\",\n                sw.toString());\n        csvPrinter.close();\n    public void testHeaderNotSet() throws IOException {\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n        printer.printRecord(\"a\", \"b\", \"c\");\n        printer.printRecord(\"x\", \"y\", \"z\");\n        assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidFormat() throws Exception {\n        final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n        new CSVPrinter(new StringWriter(), invalidFormat).close();\n    }\n    @Test\n    @Ignore\n    public void testJira135_part1() throws IOException {\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n        final List<String> list = new LinkedList<String>();\n        list.add(\"\\\"\");\n        printer.printRecord(list);\n        printer.close();\n        final String expected = \"\\\"\\\\\\\"\\\"\" + format.getRecordSeparator();\n        assertEquals(expected, sw.toString());\n        final String[] record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n    }\n    @Test\n    @Ignore\n    public void testJira135_part2() throws IOException {\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n        final List<String> list = new LinkedList<String>();\n        list.add(\"\\n\");\n        printer.printRecord(list);\n        printer.close();\n        final String expected = \"\\\"\\\\n\\\"\" + format.getRecordSeparator();\n        assertEquals(expected, sw.toString());\n        final String[] record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n    }\n    @Test\n    @Ignore\n    public void testJira135_part3() throws IOException {\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n        final List<String> list = new LinkedList<String>();\n        list.add(\"\\\\\");\n        printer.printRecord(list);\n        printer.close();\n        final String expected = \"\\\"\\\\\\\\\\\"\" + format.getRecordSeparator();\n        assertEquals(expected, sw.toString());\n        final String[] record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n    }\n    @Test\n    @Ignore\n    public void testJira135All() throws IOException {\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n        final List<String> list = new LinkedList<String>();\n        list.add(\"\\\"\");\n        list.add(\"\\n\");\n        list.add(\"\\\\\");\n        printer.printRecord(list);\n        printer.close();\n        final String expected = \"\\\"\\\\\\\"\\\",\\\"\\\\n\\\",\\\"\\\\\\\"\" + format.getRecordSeparator();\n        assertEquals(expected, sw.toString());\n        final String[] record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n    @Test\n    public void testMySqlNullStringDefault() throws IOException {\n        assertEquals(\"\\\\N\", CSVFormat.MYSQL.getNullString());\n    @Test(expected = IllegalArgumentException.class)\n    public void testNewCsvPrinterAppendableNullFormat() throws Exception {\n        new CSVPrinter(new StringWriter(), null).close();\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void testNewCSVPrinterNullAppendableFormat() throws Exception {\n        new CSVPrinter(null, CSVFormat.DEFAULT).close();\n    }\n    @Test\n    public void testParseCustomNullValues() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVFormat format = CSVFormat.DEFAULT.withNullString(\"NULL\");\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n        printer.printRecord(\"a\", null, \"b\");\n        printer.close();\n        final String csvString = sw.toString();\n        assertEquals(\"a,NULL,b\" + recordSeparator, csvString);\n        final Iterable<CSVRecord> iterable = format.parse(new StringReader(csvString));\n        final Iterator<CSVRecord> iterator = iterable.iterator();\n        final CSVRecord record = iterator.next();\n        assertEquals(\"a\", record.get(0));\n        assertEquals(null, record.get(1));\n        assertEquals(\"b\", record.get(2));\n        assertFalse(iterator.hasNext());\n        ((CSVParser) iterable).close();\n    }\n    @Test\n    public void testPlainEscaped() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n        printer.print(\"abc\");\n        printer.print(\"xyz\");\n        assertEquals(\"abc,xyz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testPlainPlain() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n        printer.print(\"abc\");\n        printer.print(\"xyz\");\n        assertEquals(\"abc,xyz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testPlainQuoted() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n        printer.print(\"abc\");\n        assertEquals(\"abc\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testPrint() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = CSVFormat.DEFAULT.print(sw);\n        printer.printRecord(\"a\", \"b\\\\c\");\n        assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testPrintCustomNullValues() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"));\n        printer.printRecord(\"a\", null, \"b\");\n        assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\n        printer.close();\n    public void testRandomTdf() throws Exception {\n        doRandom(CSVFormat.TDF, ITERATIONS_FOR_RANDOM_TEST);\n    public void testSkipHeaderRecordFalse() throws IOException {\n        final CSVPrinter printer = new CSVPrinter(sw,\n                CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(false));\n    public void testTrimOnOneColumn() throws IOException {\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim());\n        printer.print(\" A \");\n        assertEquals(\"A\", sw.toString());\n    public void testTrimOnTwoColumns() throws IOException {\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim());\n        printer.print(\" A \");\n        printer.print(\" B \");\n        assertEquals(\"A,B\", sw.toString());\n        printer.close();\n    public void testTrailingDelimiterOnTwoColumns() throws IOException {\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrailingDelimiter());\n        printer.printRecord(\"A\", \"B\");\n        assertEquals(\"A,B,\\r\\n\", sw.toString());\n        printer.close();\n    public void testTrimOffOneColumn() throws IOException {\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim(false));\n        printer.print(\" A \");\n        assertEquals(\"\\\" A \\\"\", sw.toString());\n    private String[] toFirstRecordValues(final String expected, final CSVFormat format) throws IOException {\n        return CSVParser.parse(expected, format).getRecords().get(0).values();\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                26,
                161,
                166,
                172,
                178,
                183,
                226,
                227,
                284,
                285,
                310,
                311,
                421,
                422,
                465,
                467,
                510,
                525,
                526,
                755,
                756,
                757,
                764,
                765,
                766,
                928,
                929,
                933,
                934,
                938,
                939,
                943,
                944,
                948,
                949,
                961,
                962,
                990,
                1025,
                1043,
                1074,
                1144,
                1173,
                1194,
                1219,
                1244,
                1269,
                1288,
                1319,
                1333,
                1371,
                1398,
                1399,
                1409,
                1410,
                1411,
                1412,
                1413,
                1420,
                1421,
                1422,
                1432,
                1433,
                1434,
                1435,
                1436,
                1443,
                1444
            ],
            "src/main/java/org/apache/commons/csv/CSVParser.java": [
                289,
                291,
                292,
                293,
                294,
                296,
                504,
                507,
                511
            ],
            "src/main/java/org/apache/commons/csv/CSVPrinter.java": [
                131,
                355,
                356,
                357
            ],
            "src/test/java/org/apache/commons/csv/CSVParserTest.java": [
                914,
                915,
                916,
                917,
                918,
                919,
                920,
                921,
                922,
                923,
                924,
                926,
                927,
                928,
                929,
                930,
                931,
                932,
                933,
                934,
                935,
                936
            ],
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": [
                66,
                100,
                101,
                102,
                103,
                104,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                120,
                121,
                122,
                123,
                137,
                138,
                139,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                220,
                221,
                222,
                223,
                224,
                225,
                226,
                227,
                228,
                229,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                241,
                242,
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                261,
                262,
                263,
                264,
                265,
                266,
                267,
                268,
                269,
                271,
                272,
                273,
                274,
                275,
                276,
                277,
                278,
                279,
                281,
                282,
                283,
                284,
                285,
                286,
                287,
                288,
                289,
                291,
                292,
                293,
                294,
                295,
                296,
                297,
                298,
                299,
                301,
                302,
                303,
                304,
                305,
                307,
                308,
                309,
                310,
                311,
                313,
                314,
                315,
                316,
                317,
                319,
                320,
                321,
                322,
                323,
                325,
                383,
                385,
                386,
                387,
                388,
                393,
                395,
                396,
                397,
                398,
                399,
                400,
                404,
                406,
                407,
                408,
                409,
                410,
                411,
                415,
                417,
                418,
                419,
                420,
                424,
                425,
                426,
                427,
                428,
                492,
                493,
                494,
                495,
                496,
                497,
                498,
                499,
                500,
                501,
                502,
                503,
                504,
                505,
                506,
                508,
                509,
                510,
                511,
                512,
                513,
                514,
                515,
                516,
                517,
                518,
                519,
                520,
                521,
                522,
                524,
                525,
                526,
                527,
                528,
                529,
                530,
                531,
                532,
                533,
                534,
                535,
                536,
                537,
                538,
                540,
                541,
                542,
                543,
                544,
                545,
                546,
                547,
                548,
                549,
                550,
                551,
                552,
                553,
                554,
                555,
                670,
                671,
                672,
                675,
                676,
                677,
                678,
                680,
                681,
                682,
                683,
                685,
                686,
                687,
                688,
                689,
                690,
                691,
                692,
                693,
                694,
                695,
                696,
                697,
                698,
                699,
                700,
                701,
                702,
                704,
                705,
                706,
                707,
                708,
                709,
                710,
                711,
                712,
                714,
                715,
                716,
                717,
                718,
                719,
                720,
                721,
                722,
                724,
                725,
                726,
                727,
                728,
                729,
                730,
                731,
                733,
                734,
                735,
                736,
                737,
                738,
                739,
                740,
                742,
                743,
                744,
                745,
                746,
                747,
                748,
                862,
                863,
                887,
                890,
                891,
                911,
                913,
                914,
                915,
                920,
                922,
                923,
                924,
                925,
                926,
                930,
                932,
                933,
                934,
                935,
                939,
                941,
                942,
                943,
                947,
                948
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "        Default(CSVFormat.DEFAULT), \n        Excel(CSVFormat.EXCEL), \n        MySQL(CSVFormat.MYSQL), \n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true,\n            CRLF, null, null, null, false, false, false);\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false);\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase) {\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" +\n                    quoteCharacter + \"')\");\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" +\n                    escapeCharacter + \"')\");\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" +\n                    commentMarker + \"')\");\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" +\n                    commentMarker + \"')\");\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" +\n                    commentMarker + \"')\");\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" +\n                            Arrays.toString(header));\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n                allowMissingColumnNames, ignoreHeaderCase);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n                allowMissingColumnNames, ignoreHeaderCase);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n",
            "src/main/java/org/apache/commons/csv/CSVParser.java": "    private void addRecordValue() {\n        this.record.add(input.equals(nullString) ? null : input);\n                this.addRecordValue();\n                this.addRecordValue();\n                    this.addRecordValue();\n",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": "    private final String recordSeparator = CSVFormat.DEFAULT.getRecordSeparator();\n    private void doRandom(final CSVFormat format, final int iter) throws Exception {\n        for (int i = 0; i < iter; i++) {\n            doOneRandom(format);\n        }\n    private Connection geH2Connection() throws SQLException, ClassNotFoundException {\n        Class.forName(\"org.h2.Driver\");\n        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n    }\n    @Ignore\n    public void testJira135All() throws IOException {\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n        final List<String> list = new LinkedList<String>();\n        list.add(\"\\\"\");\n        list.add(\"\\n\");\n        list.add(\"\\\\\");\n        printer.printRecord(list);\n        final String expected = \"\\\"\\\\\\\"\\\",\\\"\\\\n\\\",\\\"\\\\\\\"\" + format.getRecordSeparator();\n        assertEquals(expected, sw.toString());\n        final String[] record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n    @Ignore\n    public void testJira135_part3() throws IOException {\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n        final List<String> list = new LinkedList<String>();\n        list.add(\"\\\\\");\n        printer.printRecord(list);\n        printer.close();\n        final String expected = \"\\\"\\\\\\\\\\\"\" + format.getRecordSeparator();\n        assertEquals(expected, sw.toString());\n        final String[] record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n    @Ignore\n    public void testJira135_part2() throws IOException {\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n        final List<String> list = new LinkedList<String>();\n        list.add(\"\\n\");\n        printer.printRecord(list);\n        printer.close();\n        final String expected = \"\\\"\\\\n\\\"\" + format.getRecordSeparator();\n        assertEquals(expected, sw.toString());\n        final String[] record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n    @Ignore\n    public void testJira135_part1() throws IOException {\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n        final List<String> list = new LinkedList<String>();\n        list.add(\"\\\"\");\n        printer.printRecord(list);\n        final String expected = \"\\\"\\\\\\\"\\\"\" + format.getRecordSeparator();\n        assertEquals(expected, sw.toString());\n        final String[] record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n    private void setUpTable(final Connection connection) throws SQLException {\n        final Statement statement = connection.createStatement();\n        try {\n            statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n            statement.execute(\"insert into TEST values(1, 'r1')\");\n            statement.execute(\"insert into TEST values(2, 'r2')\");\n        } finally {\n            statement.close();\n        }\n    @Test\n    public void testMySqlNullStringDefault() throws IOException {\n        assertEquals(\"\\\\N\", CSVFormat.MYSQL.getNullString());\n    }\n    private <T> T[] expectNulls(final T[] original, final CSVFormat csvFormat) {\n        final T[] fixed = original.clone();\n        for (int i = 0; i < fixed.length; i++) {\n            if (ObjectUtils.equals(csvFormat.getNullString(), fixed[i])) {\n                fixed[i] = null;\n            }\n        }\n        return fixed;\n    private String[] toFirstRecordValues(final String expected, final CSVFormat format) throws IOException {\n        return CSVParser.parse(expected, format).getRecords().get(0).values();\n    @Test\n    public void testPrint() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = CSVFormat.DEFAULT.print(sw);\n        printer.printRecord(\"a\", \"b\\\\c\");\n        assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testPrintCustomNullValues() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"));\n        printer.printRecord(\"a\", null, \"b\");\n        assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testParseCustomNullValues() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVFormat format = CSVFormat.DEFAULT.withNullString(\"NULL\");\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n        printer.printRecord(\"a\", null, \"b\");\n        printer.close();\n        final String csvString = sw.toString();\n        assertEquals(\"a,NULL,b\" + recordSeparator, csvString);\n        final Iterable<CSVRecord> iterable = format.parse(new StringReader(csvString));\n        final Iterator<CSVRecord> iterator = iterable.iterator();\n        final CSVRecord record = iterator.next();\n        assertEquals(\"a\", record.get(0));\n        assertEquals(null, record.get(1));\n        assertEquals(\"b\", record.get(2));\n        assertFalse(iterator.hasNext());\n        ((CSVParser) iterable).close();\n    }\n    @Test\n    public void testRandomTdf() throws Exception {\n        doRandom(CSVFormat.TDF, ITERATIONS_FOR_RANDOM_TEST);\n    }\n    public void testPlainQuoted() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n        printer.print(\"abc\");\n        assertEquals(\"abc\", sw.toString());\n        printer.close();\n    public void testDelimeterQuoted() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n        printer.print(\"a,b,c\");\n        printer.print(\"xyz\");\n        assertEquals(\"'a,b,c',xyz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testDelimeterQuoteNONE() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuoteMode(QuoteMode.NONE);\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n        printer.print(\"a,b,c\");\n        printer.print(\"xyz\");\n        assertEquals(\"a!,b!,c,xyz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testEOLQuoted() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n        printer.print(\"a\\rb\\nc\");\n        printer.print(\"x\\by\\fz\");\n        assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testEscapeBackslash() throws IOException {\n        StringWriter sw = new StringWriter();\n        final char quoteChar = '\\'';\n        final String eol = \"\\r\\n\";\n        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n        printer.print(\"\\\\\");\n        printer.close();\n        assertEquals(\"'\\\\'\", sw.toString());\n        sw = new StringWriter();\n        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n        printer.print(\"\\\\\\r\");\n        printer.close();\n        assertEquals(\"'\\\\\\r'\", sw.toString());\n        sw = new StringWriter();\n        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n        printer.print(\"X\\\\\\r\");\n        printer.close();\n        assertEquals(\"'X\\\\\\r'\", sw.toString());\n        sw = new StringWriter();\n        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n        printer.printRecord(new Object[] { \"\\\\\\r\" });\n        printer.close();\n        assertEquals(\"'\\\\\\r'\" + eol, sw.toString());\n        sw = new StringWriter();\n        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n        printer.print(\"\\\\\\\\\");\n        printer.close();\n        assertEquals(\"'\\\\\\\\'\", sw.toString());\n    }\n    @Test\n    public void testPlainEscaped() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n        printer.print(\"abc\");\n        printer.print(\"xyz\");\n        assertEquals(\"abc,xyz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testDelimiterEscaped() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null));\n        printer.print(\"a,b,c\");\n        printer.print(\"xyz\");\n        assertEquals(\"a!,b!,c,xyz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testEOLEscaped() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n        printer.print(\"a\\rb\\nc\");\n        printer.print(\"x\\fy\\bz\");\n        assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testPlainPlain() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n        printer.print(\"abc\");\n        printer.print(\"xyz\");\n        assertEquals(\"abc,xyz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testDelimiterPlain() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n        printer.print(\"a,b,c\");\n        printer.print(\"xyz\");\n        assertEquals(\"a,b,c,xyz\", sw.toString());\n        printer.close();\n    }\n    @Test\n    public void testHeader() throws IOException {\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\"));\n    @Test\n    public void testHeaderNotSet() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n        printer.printRecord(\"a\", \"b\", \"c\");\n        printer.printRecord(\"x\", \"y\", \"z\");\n        assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n        printer.close();\n    }\n    public void testSkipHeaderRecordFalse() throws IOException {\n        final CSVPrinter printer = new CSVPrinter(sw,\n                CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(false));\n        printer.printRecord(\"a\", \"b\", \"c\");\n        printer.printRecord(\"x\", \"y\", \"z\");\n        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n    public void testHeaderCommentExcel() throws IOException {\n        final Date now = new Date();\n        final CSVFormat format = CSVFormat.EXCEL;\n        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\",\n                sw.toString());\n        csvPrinter.close();\n    public void testHeaderCommentTdf() throws IOException {\n        final Date now = new Date();\n        final CSVFormat format = CSVFormat.TDF;\n        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\",\n                sw.toString());\n        csvPrinter.close();\n    }\n    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat)\n            throws IOException {\n        CSVFormat format = baseFormat;\n        format = format.withHeaderComments(\"Generated by Apache Commons CSV 1.1\", now);\n        format = format.withCommentMarker('#');\n        format = format.withHeader(\"Col1\", \"Col2\");\n        final CSVPrinter csvPrinter = format.print(sw);\n        csvPrinter.printRecord(\"A\", \"B\");\n        csvPrinter.printRecord(\"C\", \"D\");\n        csvPrinter.close();\n        return csvPrinter;\n    public void testEOLPlain() throws IOException {\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n        printer.print(\"a\\rb\\nc\");\n        printer.print(\"x\\fy\\bz\");\n        assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidFormat() throws Exception {\n        final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n        new CSVPrinter(new StringWriter(), invalidFormat).close();\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void testNewCSVPrinterNullAppendableFormat() throws Exception {\n        new CSVPrinter(null, CSVFormat.DEFAULT).close();\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void testNewCsvPrinterAppendableNullFormat() throws Exception {\n        new CSVPrinter(new StringWriter(), null).close();\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                160,
                165,
                170,
                212,
                213,
                351,
                432,
                832,
                833,
                837,
                838,
                842,
                843,
                847,
                848,
                852,
                853,
                865,
                866,
                894,
                929,
                947,
                978,
                1048,
                1077,
                1098,
                1123,
                1148,
                1173,
                1194,
                1225,
                1239,
                1277,
                1304
            ],
            "src/main/java/org/apache/commons/csv/CSVParser.java": [
                289,
                292,
                500,
                503,
                507
            ],
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": [
                53,
                112,
                113,
                114,
                115,
                231,
                232,
                233,
                234,
                237,
                238,
                239,
                241,
                242,
                243,
                244,
                245,
                246,
                248,
                249,
                250,
                251,
                255,
                256,
                257,
                259,
                260,
                261,
                262,
                263,
                264,
                265,
                266,
                267,
                271,
                272,
                273,
                275,
                276,
                277,
                278,
                279,
                280,
                281,
                282,
                283,
                287,
                288,
                289,
                291,
                292,
                293,
                294,
                296,
                297,
                298,
                299,
                364,
                365,
                366,
                367,
                368,
                369,
                370,
                371,
                372,
                385,
                386,
                387,
                388,
                496,
                497,
                498,
                499,
                500,
                501,
                502,
                503,
                506,
                507,
                573,
                574,
                575,
                576,
                577,
                578,
                579,
                580,
                591,
                592,
                593,
                594,
                595,
                596,
                597,
                598,
                600,
                601,
                602,
                603,
                604,
                605,
                606,
                607,
                608,
                609,
                610,
                611,
                612,
                613,
                614,
                615,
                616,
                617,
                652,
                653,
                654,
                655,
                663,
                664,
                665,
                666,
                667,
                668,
                692,
                693,
                694,
                695,
                696,
                697,
                698,
                699,
                701,
                702,
                703,
                704,
                705,
                706,
                707,
                708,
                709,
                710,
                712,
                713,
                714,
                715,
                716,
                717,
                718,
                719,
                720,
                722,
                723,
                724,
                725,
                726,
                727,
                728,
                729,
                730,
                732,
                733,
                734,
                735,
                736,
                738,
                739,
                740,
                741,
                742,
                744,
                745,
                746,
                747,
                748,
                750,
                751,
                752,
                753,
                754,
                756,
                758,
                759,
                760,
                761,
                762,
                763,
                764,
                765,
                766,
                768,
                769,
                770,
                771,
                772,
                773,
                774,
                775,
                776,
                778,
                779,
                780,
                781,
                782,
                783,
                784,
                785,
                786,
                788,
                789,
                790,
                791,
                792,
                793,
                794,
                795,
                796,
                798,
                799,
                800,
                801,
                802,
                803,
                804,
                805,
                806,
                808,
                809,
                811,
                818,
                819,
                820,
                821,
                822,
                823,
                824,
                825,
                826,
                841,
                844,
                845,
                846,
                847,
                848,
                853,
                855,
                856,
                857,
                858,
                859,
                860,
                864,
                866,
                867,
                868,
                869,
                870,
                871,
                872,
                874,
                875,
                876,
                878,
                879,
                880,
                881,
                882,
                883,
                884,
                885,
                889,
                891,
                892,
                893,
                894,
                898,
                899,
                900,
                901,
                902,
                904,
                905,
                906,
                907,
                909,
                910,
                911
            ]
        }
    },
    {
        "commit": "190390bf",
        "prev_commit": "1023690d",
        "changed_files": [
            "src/changes/changes.xml",
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java"
        ],
        "changed_files_num": 3,
        "changed_java_files": [
            "src/main/java/org/apache/commons/csv/CSVFormat.java",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java"
        ],
        "changed_java_files_num": 2,
        "failed_test_list": [],
        "passed_test_list": [
            "ExtendedBufferedReaderTest",
            "TokenMatchersTest",
            "CSVFileParserTest",
            "CSVPrinterTest",
            "LexerTest",
            "AssertionsTest",
            "JiraCsv167Test",
            "CSVParserTest",
            "CSVFormatTest",
            "JiraCsv164Test",
            "CSVFormatPredefinedTest",
            "CSVRecordTest"
        ],
        "tests_cases_num": {
            "AssertionsTest": 2,
            "CSVFileParserTest": 12,
            "CSVFormatPredefinedTest": 5,
            "CSVFormatTest": 47,
            "CSVParserTest": 69,
            "CSVPrinterTest": 74,
            "CSVRecordTest": 17,
            "ExtendedBufferedReaderTest": 5,
            "LexerTest": 26,
            "TokenMatchersTest": 4,
            "JiraCsv164Test": 2,
            "JiraCsv167Test": 1
        },
        "ekstazi_test_list": [],
        "ekstazi_failed_test_list": [],
        "starts_test_list": [],
        "starts_failed_test_list": [],
        "diff_code": "+      <action issue=\"CSV-171\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, Michael Graessle, Adrian Bridgett\">Negative numeric values in the first column are always quoted in minimal mode.</action>\n+                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n+    private static final char DQUOTE_CHAR = '\"';\n+    private static final char BACKSLASH_CH = '\\\\';\n+                ch = DQUOTE_CHAR;\n+                ch = BACKSLASH_CH;\n+        assertEquals(\"\\\\\", sw.toString());\n+        assertEquals(\"\\\\\\\\\", sw.toString());\n+        assertEquals(\"\\\\\\\\\", sw.toString());\n+    }\n+    @Test\n+    public void testEscapeNull1() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            printer.print(\"\\\\\");\n+        }\n+        assertEquals(\"\\\\\", sw.toString());\n+    }\n+    @Test\n+    public void testEscapeNull2() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            printer.print(\"\\\\\\r\");\n+        }\n+        assertEquals(\"\\\"\\\\\\r\\\"\", sw.toString());\n+    }\n+    @Test\n+    public void testEscapeNull3() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            printer.print(\"X\\\\\\r\");\n+        }\n+        assertEquals(\"\\\"X\\\\\\r\\\"\", sw.toString());\n+    }\n+    @Test\n+    public void testEscapeNull4() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            printer.print(\"\\\\\\\\\");\n+        }\n+        assertEquals(\"\\\\\\\\\", sw.toString());\n+    }\n+    @Test\n+    public void testEscapeNull5() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            printer.print(\"\\\\\\\\\");\n+        }\n+        assertEquals(\"\\\\\\\\\", sw.toString());\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH_CH);\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH_CH);\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH_CH);\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH_CH);\n+        CSVFormat format = CSVFormat.MYSQL.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.NON_NUMERIC);\n",
        "diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": "    private static final char DQUOTE_CHAR = '\"';\n    private static final char BACKSLASH_CH = '\\\\';\n                ch = DQUOTE_CHAR;\n                ch = BACKSLASH_CH;\n        assertEquals(\"\\\\\", sw.toString());\n        assertEquals(\"\\\\\\\\\", sw.toString());\n        assertEquals(\"\\\\\\\\\", sw.toString());\n    }\n    @Test\n    public void testEscapeNull1() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n            printer.print(\"\\\\\");\n        }\n        assertEquals(\"\\\\\", sw.toString());\n    }\n    @Test\n    public void testEscapeNull2() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n            printer.print(\"\\\\\\r\");\n        }\n        assertEquals(\"\\\"\\\\\\r\\\"\", sw.toString());\n    }\n    @Test\n    public void testEscapeNull3() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n            printer.print(\"X\\\\\\r\");\n        }\n        assertEquals(\"\\\"X\\\\\\r\\\"\", sw.toString());\n    }\n    @Test\n    public void testEscapeNull4() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n            printer.print(\"\\\\\\\\\");\n        }\n        assertEquals(\"\\\\\\\\\", sw.toString());\n    }\n    @Test\n    public void testEscapeNull5() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n            printer.print(\"\\\\\\\\\");\n        }\n        assertEquals(\"\\\\\\\\\", sw.toString());\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH_CH);\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH_CH);\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH_CH);\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH_CH);\n        CSVFormat format = CSVFormat.MYSQL.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.NON_NUMERIC);\n"
        },
        "diff_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                1039
            ],
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": [
                56,
                57,
                189,
                195,
                301,
                328,
                337,
                338,
                340,
                341,
                342,
                343,
                344,
                345,
                346,
                347,
                349,
                350,
                351,
                352,
                353,
                354,
                355,
                356,
                358,
                359,
                360,
                361,
                362,
                363,
                364,
                365,
                367,
                368,
                369,
                370,
                371,
                372,
                373,
                374,
                376,
                377,
                378,
                379,
                380,
                381,
                382,
                539,
                555,
                571,
                587,
                616
            ]
        },
        "starts_total_time": 0,
        "ekstazi_total_time": 0,
        "ekstazi_select_time": 0,
        "starts_select_time": 0,
        "deleted_diff_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": "                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n",
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": "                ch = '\"';\n                ch = '\\\\';\n        assertEquals(\"'\\\\'\", sw.toString());\n        assertEquals(\"'\\\\\\\\'\", sw.toString());\n        assertEquals(\"'\\\\\\\\'\", sw.toString());\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n        CSVFormat format = CSVFormat.MYSQL.withQuote('\"').withNullString(\"NULL\").withQuoteMode(QuoteMode.NON_NUMERIC);\n"
        },
        "deleted_line_number_list_per_file": {
            "src/main/java/org/apache/commons/csv/CSVFormat.java": [
                1039
            ],
            "src/test/java/org/apache/commons/csv/CSVPrinterTest.java": [
                187,
                193,
                299,
                327,
                336,
                493,
                509,
                525,
                541,
                570
            ]
        }
    }
]